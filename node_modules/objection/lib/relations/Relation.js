'use strict';

var _desc, _value, _class;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _classUtils = require('../utils/classUtils');

var _decorators = require('../utils/decorators');

var _QueryBuilder = require('../queryBuilder/QueryBuilder');

var _QueryBuilder2 = _interopRequireDefault(_QueryBuilder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @typedef {Object} RelationJoin
 *
 * An object literal that describes how two tables are related to one another. For example:
 *
 * ```js
 * {
 *   from: 'Animal.ownerId',
 *   to: 'Person.id'
 * }
 * ```
 *
 * or in the case of a many-to-many relation:
 *
 * ```js
 * {
 *   from: 'Person.id',
 *   through: {
 *     from: 'Person_Movie.actorId',
 *     to: 'Person_Movie.movieId'
 *   },
 *   to: 'Movie.id'
 * }
 * ```
 *
 * @property {string|Array.<string>} from
 *    The relation column in the owner table. Must be given with the table name.
 *    For example `Person.id`. Composite key can be specified using an array of
 *    columns e.g. `['Person.a', 'Person.b']`. Note that neither this nor `to`
 *    need to be foreign keys or primary keys. You can join any column to
 *    any column.
 *
 * @property {string|Array.<string>} to
 *    The relation column in the related table. Must be given with the table name.
 *    For example `Movie.id`. Composite key can be specified using an array of
 *    columns e.g. `['Movie.a', 'Movie.b']`. Note that neither this nor `from`
 *    need to be foreign keys or primary keys. You can join any column to any column.
 *
 * @property {Object} through
 *    Describes the join table if the models are related through one.
 *
 * @property {Class.<Model>} through.modelClass
 *    If the there is model class available for the join table, it can be provided
 *    using this property.
 *
 * @property {string|Array.<string>} through.from
 *    The column that is joined to `from` property of the `RelationJoin`. For example
 *    `Person_Movie.actorId` where `Person_Movie` is the join table. Composite key can
 *    be specified using an array of columns e.g. `['Person_Movie.a', 'Person_Movie.b']`.
 *
 * @property {string|Array.<string>} through.to
 *    The column that is joined to `to` property of the `RelationJoin`. For example
 *    `Person_Movie.movieId` where `Person_Movie` is the join table. Composite key can
 *    be specified using an array of columns e.g. `['Person_Movie.a', 'Person_Movie.b']`.
 */

/**
 * @typedef {Object} RelationMapping
 *
 * @property {Class.<Model>|string} modelClass
 *    A {@link Model} subclass constructor or an absolute path to a module that exports one.
 *
 * @property {Relation} relation
 *    A relation constructor. You can use one of Model.OneToOneRelation, Model.OneToManyRelation and
 *    Model.ManyToManyRelation or even write your own relation type by subclassing {@link Relation}.
 *
 * @property {Object|function(QueryBuilder)} filter
 *    Additional filter for the relation. It can be either a hash of {column: 'value'} pairs or
 *    a function that takes a QueryBuilder as a parameter.
 *
 * @property {RelationJoin} [join]
 *    An object that describes how the two models are related.
 */

/**
 * Represents a relation between two `Model` subclasses.
 *
 * This is an abstract base class and should never be instantiated.
 *
 * @param {string} relationName
 *    Name of the relation.
 *
 * @param {Model} OwnerClass
 *    The Model subclass that owns this relation.
 *
 * @ignore
 * @abstract
 */
var Relation = (_class = function () {
  function Relation(relationName, OwnerClass) {
    (0, _classCallCheck3.default)(this, Relation);

    /**
     * Name of the relation.
     *
     * @type {string}
     */
    this.name = relationName;

    /**
     * The owner class of this relation.
     *
     * This must be a subclass of Model.
     *
     * @type {Class.<Model>}
     */
    this.ownerModelClass = OwnerClass;

    /**
     * The related class.
     *
     * This must be a subclass of Model.
     *
     * @type {Class.<Model>}
     */
    this.relatedModelClass = null;

    /**
     * The relation column in the owner table.
     *
     * @type {Array.<string>}
     */
    this.ownerCol = null;

    /**
     * The relation property in the owner model.
     *
     * @type {Array.<string>}
     */
    this.ownerProp = null;

    /**
     * The relation column in the related table.
     *
     * @type {Array.<string>}
     */
    this.relatedCol = null;

    /**
     * The relation property in the related model.
     *
     * @type {Array.<string>}
     */
    this.relatedProp = null;

    /**
     * Optional additional filter query.
     *
     * @type {function (QueryBuilder)}
     */
    this.filter = null;
  }

  /**
   * Makes the given constructor a subclass of this class.
   *
   * @param {function=} subclassConstructor
   * @return {Class.<Model>}
   */

  (0, _createClass3.default)(Relation, [{
    key: 'setMapping',

    /**
     * Constructs the instance based on a mapping data.
     *
     * @param {RelationMapping} mapping
     */
    value: function setMapping(mapping) {
      // Avoid require loop and import here.
      var Model = require(__dirname + '/../model/Model').default;

      if (!(0, _classUtils.isSubclassOf)(this.ownerModelClass, Model)) {
        this.throwError('Relation\'s owner is not a subclass of Model');
      }

      if (!mapping.modelClass) {
        this.throwError('modelClass is not defined');
      }

      if (_lodash2.default.isString(mapping.modelClass)) {
        try {
          // babel 6 style of exposing es6 exports to commonjs https://github.com/babel/babel/issues/2683
          var relatedModelClassModule = require(mapping.modelClass);
          this.relatedModelClass = (0, _classUtils.isSubclassOf)(relatedModelClassModule.default, Model) ? relatedModelClassModule.default : relatedModelClassModule;
        } catch (err) {
          this.throwError('modelClass is an invalid file path to a model class.');
        }

        if (!(0, _classUtils.isSubclassOf)(this.relatedModelClass, Model)) {
          this.throwError('modelClass is a valid path to a module, but the module doesn\'t export a Model subclass.');
        }
      } else {
        this.relatedModelClass = mapping.modelClass;

        if (!(0, _classUtils.isSubclassOf)(this.relatedModelClass, Model)) {
          this.throwError('modelClass is not a subclass of Model or a file path to a module that exports one.');
        }
      }

      if (!mapping.relation) {
        this.throwError('relation is not defined');
      }

      if (!(0, _classUtils.isSubclassOf)(mapping.relation, Relation)) {
        this.throwError('relation is not a subclass of Relation');
      }

      if (!mapping.join || !mapping.join.from || !mapping.join.to) {
        this.throwError('join must be an object that maps the columns of the related models together. For example: {from: "SomeTable.id", to: "SomeOtherTable.someModelId"}');
      }

      var joinOwner = null;
      var joinRelated = null;

      var joinFrom = this.parseReference(mapping.join.from);
      var joinTo = this.parseReference(mapping.join.to);

      if (!joinFrom.table || _lodash2.default.isEmpty(joinFrom.columns)) {
        this.throwError('join.from must have format TableName.columnName. For example "SomeTable.id" or in case of composite key ["SomeTable.a", "SomeTable.b"].');
      }

      if (!joinTo.table || _lodash2.default.isEmpty(joinTo.columns)) {
        this.throwError('join.to must have format TableName.columnName. For example "SomeTable.id" or in case of composite key ["SomeTable.a", "SomeTable.b"].');
      }

      if (joinFrom.table === this.ownerModelClass.tableName) {
        joinOwner = joinFrom;
        joinRelated = joinTo;
      } else if (joinTo.table === this.ownerModelClass.tableName) {
        joinOwner = joinTo;
        joinRelated = joinFrom;
      } else {
        this.throwError('join: either `from` or `to` must point to the owner model table.');
      }

      if (joinRelated.table !== this.relatedModelClass.tableName) {
        this.throwError('join: either `from` or `to` must point to the related model table.');
      }

      this.ownerCol = joinOwner.columns;
      this.ownerProp = this.propertyName(this.ownerCol, this.ownerModelClass);
      this.relatedCol = joinRelated.columns;
      this.relatedProp = this.propertyName(this.relatedCol, this.relatedModelClass);
      this.filter = this.parseFilter(mapping);
    }

    /**
     * Return the knex connection.
     */

  }, {
    key: 'knex',
    value: function knex() {
      return this.ownerModelClass.knex();
    }

    /**
     * Reference to the relation column in the owner model's table.
     *
     * For example: [`Person.id`].
     *
     * @returns {Array.<string>}
     */

  }, {
    key: 'fullOwnerCol',
    value: function fullOwnerCol() {
      var _this = this;

      return _lodash2.default.map(this.ownerCol, function (col) {
        return _this.ownerModelClass.tableName + '.' + col;
      });
    }

    /**
     * Reference to the relation column in the related model's table.
     *
     * For example: [`Movie.id`].
     *
     * @returns {Array.<string>}
     */

  }, {
    key: 'fullRelatedCol',
    value: function fullRelatedCol() {
      var _this2 = this;

      return _lodash2.default.map(this.relatedCol, function (col) {
        return _this2.relatedModelClass.tableName + '.' + col;
      });
    }

    /**
     * Alias to use for the related table when joining with the owner table.
     *
     * For example: `Movie_rel_movies`.
     *
     * @returns {string}
     */

  }, {
    key: 'relatedTableAlias',
    value: function relatedTableAlias() {
      return this.relatedModelClass.tableName + '_rel_' + this.name;
    }

    /**
     * Clones this relation.
     *
     * @returns {Relation}
     */

  }, {
    key: 'clone',
    value: function clone() {
      var relation = new this.constructor(this.name, this.ownerModelClass);

      relation.relatedModelClass = this.relatedModelClass;
      relation.ownerCol = this.ownerCol;
      relation.ownerProp = this.ownerProp;
      relation.relatedCol = this.relatedCol;
      relation.relatedProp = this.relatedProp;
      relation.filter = this.filter;

      return relation;
    }

    /**
     * Returns a clone of this relation with `relatedModelClass` and `ownerModelClass` bound to the given knex.
     *
     * See `Model.bindKnex`.
     *
     * @param knex
     * @returns {Relation}
     */

  }, {
    key: 'bindKnex',
    value: function bindKnex(knex) {
      var bound = this.clone();

      bound.relatedModelClass = this.relatedModelClass.bindKnex(knex);
      bound.ownerModelClass = this.ownerModelClass.bindKnex(knex);

      return bound;
    }

    /**
     * @protected
     * @param {Array.<Model>} models1
     * @param {Array.<Model>} models2
     * @returns {Array.<Model>}
     */

  }, {
    key: 'mergeModels',
    value: function mergeModels(models1, models2) {
      var modelsById = (0, _create2.default)(null);

      models1 = _lodash2.default.compact(models1);
      models2 = _lodash2.default.compact(models2);

      _lodash2.default.forEach(models1, function (model) {
        modelsById[model.$id()] = model;
      });

      _lodash2.default.forEach(models2, function (model) {
        modelsById[model.$id()] = model;
      });

      var models = _lodash2.default.values(modelsById);
      if (models.length === 0) {
        return [];
      }

      var modelClass = models[0].constructor;
      var idProperty = modelClass.getIdProperty();
      if (!_lodash2.default.isArray(idProperty)) {
        idProperty = [idProperty];
      }

      return _lodash2.default.sortByAll(models, idProperty);
    }

    /**
     * @param {QueryBuilder} builder
     * @param {Array.<string>|Array.<Array.<(string|number)>>} ownerIds
     * @param {boolean=} isColumnRef
     * @returns {QueryBuilder}
     */

  }, {
    key: 'findQuery',
    value: function findQuery(builder, ownerIds, isColumnRef) {
      var fullRelatedCol = this.fullRelatedCol();

      if (isColumnRef) {
        _lodash2.default.each(fullRelatedCol, function (col, idx) {
          builder.whereRef(col, ownerIds[idx]);
        });
      } else {
        if ((0, _lodash2.default)(ownerIds).flatten().all(function (id) {
          return _lodash2.default.isNull(id) || _lodash2.default.isUndefined(id);
        })) {
          // Nothing to fetch.
          builder.resolve([]);
        } else {
          builder.whereInComposite(fullRelatedCol, ownerIds);
        }
      }

      return builder.call(this.filter);
    }

    /**
     * @param {QueryBuilder} builder
     * @param {string=} joinMethod
     * @returns {QueryBuilder}
     */

  }, {
    key: 'join',
    value: function join(builder, joinMethod) {
      joinMethod = joinMethod || 'join';

      var relatedTable = this.relatedModelClass.tableName;
      var relatedTableAlias = this.relatedTableAlias();

      var relatedTableAsAlias = relatedTable + ' as ' + relatedTableAlias;
      var relatedCol = _lodash2.default.map(this.relatedCol, function (col) {
        return relatedTableAlias + '.' + col;
      });
      var ownerCol = this.fullOwnerCol();

      return builder[joinMethod](relatedTableAsAlias, function (join) {
        _lodash2.default.each(relatedCol, function (relatedCol, idx) {
          join.on(relatedCol, '=', ownerCol[idx]);
        });
      }).call(this.filter);
    }

    /* istanbul ignore next */
    /**
     * @abstract
     * @param {QueryBuilder} builder
     * @param {Array.<Model>} owners
     */

  }, {
    key: 'find',
    value: function find(builder, owners) {
      this.throwError('not implemented');
    }

    /* istanbul ignore next */
    /**
     * @abstract
     * @param {QueryBuilder} builder
     * @param {Model} owner
     * @param {InsertionOrUpdate} insertion
     */

  }, {
    key: 'insert',
    value: function insert(builder, owner, insertion) {
      this.throwError('not implemented');
    }

    /**
     * @param {QueryBuilder} builder
     * @param {Model} owner
     * @param {InsertionOrUpdate} update
     */

  }, {
    key: 'update',
    value: function update(builder, owner, _update) {
      var _this3 = this;

      builder.onBuild(function (builder) {
        _this3.findQuery(builder, [owner.$values(_this3.ownerProp)]);
        builder.$$update(_update);
      });
    }

    /**
     * @param {QueryBuilder} builder
     * @param {Model} owner
     * @param {InsertionOrUpdate} patch
     */

  }, {
    key: 'patch',
    value: function patch(builder, owner, _patch) {
      return this.update(builder, owner, _patch);
    }

    /**
     * @param {QueryBuilder} builder
     * @param {Model} owner
     */

  }, {
    key: 'delete',
    value: function _delete(builder, owner) {
      var _this4 = this;

      builder.onBuild(function (builder) {
        _this4.findQuery(builder, [owner.$values(_this4.ownerProp)]);
        builder.$$delete();
      });
    }

    /* istanbul ignore next */
    /**
     * @abstract
     * @param {QueryBuilder} builder
     * @param {Model|Object} owner
     * @param {number|string|Array.<number|string>|Array.<Array.<number|string>>} ids
     */

  }, {
    key: 'relate',
    value: function relate(builder, owner, ids) {
      this.throwError('not implemented');
    }

    /* istanbul ignore next */
    /**
     * @abstract
     * @param {QueryBuilder} builder
     * @param {Model|Object} owner
     */

  }, {
    key: 'unrelate',
    value: function unrelate(builder, owner) {
      this.throwError('not implemented');
    }

    /**
     * @protected
     */

  }, {
    key: 'propertyName',
    value: function propertyName(columns, modelClass) {
      var _this5 = this;

      return _lodash2.default.map(columns, function (column) {
        var propertyName = modelClass.columnNameToPropertyName(column);

        if (!propertyName) {
          throw new Error(modelClass.name + '.$parseDatabaseJson probably transforms the value of the column ' + column + '.' + ' This is a no-no because ' + column + ' is needed in the relation ' + _this5.ownerModelClass.tableName + '.' + _this5.name);
        }

        return propertyName;
      });
    }

    /**
     * @protected
     */

  }, {
    key: 'parseFilter',
    value: function parseFilter(mapping) {
      if (_lodash2.default.isFunction(mapping.filter)) {
        return mapping.filter;
      } else if (_lodash2.default.isObject(mapping.filter)) {
        return function (queryBuilder) {
          queryBuilder.where(mapping.filter);
        };
      } else {
        return _lodash2.default.noop;
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'parseReference',
    value: function parseReference(ref) {
      if (!_lodash2.default.isArray(ref)) {
        ref = [ref];
      }

      var table = null;
      var columns = [];

      for (var i = 0; i < ref.length; ++i) {
        var parts = ref[i].split('.');
        var tableName = parts[0] && parts[0].trim();
        var columnName = parts[1] && parts[1].trim();

        if (!tableName || table && table !== tableName || !columnName) {
          return {
            table: null,
            columns: []
          };
        } else {
          table = tableName;
        }

        columns.push(columnName);
      }

      return {
        table: table,
        columns: columns
      };
    }

    /**
     * @protected
     */

  }, {
    key: 'normalizeId',
    value: function normalizeId(ids, compositeLength) {
      var _this6 = this;

      var isComposite = compositeLength > 1;

      if (isComposite) {
        // For composite ids these two are okay:
        //
        // 1. [1, 3, 4]
        // 2. [[1, 3, 4], [4, 6, 1]]
        //
        if (!_lodash2.default.isArray(ids) || !_lodash2.default.isArray(ids[0]) && ids.length !== compositeLength) {
          this.throwError('Invalid composite key ' + ids);
        }

        // Normalize to array of arrays.
        if (!_lodash2.default.isArray(ids[0])) {
          ids = [ids];
        }
      } else {
        // Normalize to array of arrays.
        if (!_lodash2.default.isArray(ids)) {
          ids = [[ids]];
        } else if (!_lodash2.default.isArray(ids[0])) {
          ids = _lodash2.default.map(ids, function (id) {
            return [id];
          });
        }
      }

      _lodash2.default.each(ids, function (id) {
        if (id.length !== compositeLength) {
          _this6.throwError('Id ' + id + ' has invalid length. Expected ' + compositeLength);
        }
      });

      return ids;
    }

    /**
     * @protected
     */

  }, {
    key: 'throwError',
    value: function throwError(message) {
      if (this.ownerModelClass && this.ownerModelClass.name && this.name) {
        throw new Error(this.ownerModelClass.name + '.relationMappings.' + this.name + ': ' + message);
      } else {
        throw new Error(this.constructor.name + ': ' + message);
      }
    }
  }], [{
    key: 'extend',
    value: function extend(subclassConstructor) {
      (0, _classUtils.inherits)(subclassConstructor, this);
      return subclassConstructor;
    }
  }]);
  return Relation;
}(), (_applyDecoratedDescriptor(_class.prototype, 'fullOwnerCol', [_decorators.memoize], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'fullOwnerCol'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'fullRelatedCol', [_decorators.memoize], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'fullRelatedCol'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'relatedTableAlias', [_decorators.memoize], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'relatedTableAlias'), _class.prototype)), _class);
exports.default = Relation;