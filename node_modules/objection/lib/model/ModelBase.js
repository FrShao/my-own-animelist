'use strict';

var _desc, _value, _class, _class2, _temp;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _tv = require('tv4');

var _tv2 = _interopRequireDefault(_tv);

var _tv4Formats = require('tv4-formats');

var _tv4Formats2 = _interopRequireDefault(_tv4Formats);

var _ValidationError = require('../ValidationError');

var _ValidationError2 = _interopRequireDefault(_ValidationError);

var _classUtils = require('../utils/classUtils');

var _decorators = require('../utils/decorators');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @typedef {Object} ModelOptions
 *
 * @property {boolean} [patch]
 *    If true the json is treated as a patch and the `required` field of the json schema is
 *    ignored in the validation. This allows us to create models with a subset of required
 *    properties for patch operations.
 *
 * @property {boolean} [skipValidation]
 *    If true the json schema validation is skipped.
 */

/**
 * Base class for models.
 *
 * ModelBase provides a mechanism for automatic JSON validation and a way to attach
 * functionality to plain javascript objects. A subclass can be created like this:
 *
 * ```js
 * function Person() {
 *   ModelBase.apply(this, arguments);
 * }
 *
 * ModelBase.extend(Person);
 *
 * Person.prototype.fullName = function () {
 *   return this.firstName + ' ' + this.lastName;
 * };
 *
 * Person.jsonSchema = {
 *   type: 'object',
 *   properties: {
 *     id: {type: 'integer'},
 *     firstName: {type: 'string'},
 *     lastName: {type: 'string'}
 *   }
 * };
 * ```
 *
 * Use `ModelBase.from*Json` methods to create models from JSON objects:
 *
 * ```js
 * var person = Person.fromJson({firstName: 'Jennifer', lastName: 'Lawrence'});
 *
 * console.log(person.firstName); // --> 'Jennifer'
 * console.log(person.lastName); // --> 'Lawrence'
 * console.log(person.fullName()); // --> 'Jennifer Lawrence'
 *
 * // This throws because the schema validation fails.
 * var person2 = Person.fromJson({firstName: 10});
 * ```
 *
 * Properties that are prefixed with '$' are excluded from all JSON representations:
 *
 * ```js
 * var person = Person.fromJson({firstName: 'Jennifer');
 * person.$spam = 100;
 *
 * console.log(person); // --> {firstName: 'Jennifer'}
 * console.log(person.$toJson()); // --> {firstName: 'Jennifer'}
 * ```
 *
 * ModelBase makes it possible to have a different database representation for a model.
 * For example if your column names are snake_cased in the database but you want to use
 * camelCased properties in the code and outside the server you can do this:
 *
 * ```js
 * // This is called when an object is serialized to database format.
 * Person.prototype.$formatDatabaseJson = function (json) {
 *   // Call superclass implementation.
 *   json = ModelBase.prototype.$formatDatabaseJson.call(this, json);
 *
 *   return _.mapKeys(json, function (value, key) {
 *     return _.snakeCase(key);
 *   });
 * };
 *
 * // This is called when an object is read from database.
 * Person.prototype.$parseDatabaseJson = function (json) {
 *   json = _.mapKeys(json, function (value, key) {
 *     return _.camelCase(key);
 *   });
 *
 *   // Call superclass implementation.
 *   return ModelBase.prototype.$parseDatabaseJson.call(this, json);
 * };
 * ```
 *
 * @constructor
 */
var ModelBase = (_class = (_temp = _class2 = function () {
  function ModelBase() {
    (0, _classCallCheck3.default)(this, ModelBase);
  }

  (0, _createClass3.default)(ModelBase, [{
    key: '$beforeValidate',

    /**
     * This is called before validation.
     *
     * Here you can dynamically edit the jsonSchema if needed.
     *
     * @param {Object} jsonSchema
     *    A deep clone of this class's jsonSchema.
     *
     * @param {Object} json
     *    The JSON object to be validated.
     *
     * @param {ModelOptions=} options
     *    Optional options.
     *
     * @return {Object}
     *    The (possibly) modified jsonSchema.
     */
    value: function $beforeValidate(jsonSchema, json, options) {
      /* istanbul ignore next */
      return jsonSchema;
    }

    /**
     * Validates the given JSON object.
     *
     * Calls `$beforeValidation` and `$afterValidation` methods. This method is called
     * automatically from `fromJson` and `$setJson` methods. This method can also be
     * called explicitly when needed.
     *
     * @throws {ValidationError}
     *    If validation fails.
     *
     * @param {Object=} json
     *    If not given ==> this.
     *
     * @param {ModelOptions=} options
     *    Optional options.
     *
     * @return {Object}
     *    The input json
     */

    /**
     * The optional schema against which the JSON is validated.
     *
     * The jsonSchema can be dynamically modified in the `$beforeValidate` method.
     *
     * Must follow http://json-schema.org specification. If null no validation is done.
     *
     * @see $beforeValidate()
     * @see $validate()
     * @see $afterValidate()
     *
     * @type {Object}
     */

  }, {
    key: '$validate',
    value: function $validate() {
      var json = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var ModelClass = this.constructor;
      var jsonSchema = ModelClass.jsonSchema;

      if (!jsonSchema || options.skipValidation) {
        return json;
      }

      // No need to call $beforeValidate (and clone the jsonSchema) if $beforeValidate has not been overwritten.
      if (this.$beforeValidate !== ModelBase.prototype.$beforeValidate) {
        jsonSchema = _lodash2.default.cloneDeep(jsonSchema);
        jsonSchema = this.$beforeValidate(jsonSchema, json, options);
      }

      var report = tryValidate(jsonSchema, json, options);
      var validationError = parseValidationError(report);

      if (validationError) {
        throw validationError;
      }

      this.$afterValidate(json, options);
      return json;
    }

    /**
     * This is called after successful validation.
     *
     * You can do further validation here and throw a ValidationError if something goes wrong.
     *
     * @param {Object=} json
     *    The JSON object to validate.
     *
     * @param {ModelOptions=} options
     *    Optional options.
     */

  }, {
    key: '$afterValidate',
    value: function $afterValidate(json, options) {}
    // Do nothing by default.

    /**
     * This is called when a ModelBase is created from a database JSON object.
     *
     * Converts the JSON object from the database format to the internal format.
     *
     * @note This function must handle the case where any subset of the columns comes
     *    in the `json` argument. You cannot assume that all columns are present as it
     *    depends on the select statement. There can also be additional columns because
     *    of join clauses, aliases etc.
     *
     * @note If you override this remember to call the super class's implementation.
     *
     * @param {Object} json
     *    The JSON object in database format.
     *
     * @return {Object}
     *    The JSON object in internal format.
     */

  }, {
    key: '$parseDatabaseJson',
    value: function $parseDatabaseJson(json) {
      return json;
    }

    /**
     * This is called when a ModelBase is converted to database format.
     *
     * Converts the JSON object from the internal format to the database format.
     *
     * @note If you override this remember to call the super class's implementation.
     *
     * @param {Object} json
     *    The JSON object in internal format.
     *
     * @return {Object}
     *    The JSON object in database format.
     */

  }, {
    key: '$formatDatabaseJson',
    value: function $formatDatabaseJson(json) {
      return json;
    }

    /**
     * This is called when a ModelBase is created from a JSON object.
     *
     * Converts the JSON object to the internal format.
     *
     * @note If you override this remember to call the super class's implementation.
     *
     * @param {Object} json
     *    The JSON object in external format.
     *
     * @param {ModelOptions=} options
     *    Optional options.
     *
     * @return {Object}
     *    The JSON object in internal format.
     */

  }, {
    key: '$parseJson',
    value: function $parseJson(json, options) {
      return json;
    }

    /**
     * This is called when a ModelBase is converted to JSON.
     *
     * @note Remember to call the super class's implementation.
     *
     * @param {Object} json
     *    The JSON object in internal format
     *
     * @return {Object}
     *    The JSON object in external format.
     */

  }, {
    key: '$formatJson',
    value: function $formatJson(json) {
      return json;
    }

    /**
     * Exports this model as a database JSON object.
     *
     * Calls `$formatDatabaseJson()`.
     *
     * @return {Object}
     *    This model as a JSON object in database format.
     */

  }, {
    key: '$toDatabaseJson',
    value: function $toDatabaseJson() {
      return this.$$toJson(true, null, null);
    }

    /**
     * Exports this model as a JSON object.
     *
     * Calls `$formatJson()`.
     *
     * @return {Object}
     *    This model as a JSON object.
     */

  }, {
    key: '$toJson',
    value: function $toJson() {
      return this.$$toJson(false, null, null);
    }

    /**
     * Alias for `this.$toJson()`.
     *
     * For JSON.stringify compatibility.
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.$toJson();
    }

    /**
     * Sets the values from a JSON object.
     *
     * Validates the JSON before setting values. Calls `this.$parseJson()`.
     *
     * @param {Object} json
     *    The JSON object to set.
     *
     * @param {ModelOptions=} options
     *    Optional options.
     *
     * @returns {ModelBase} `this` for chaining.
     *
     * @throws ValidationError
     *    If validation fails.
     */

  }, {
    key: '$setJson',
    value: function $setJson(json) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      json = json || {};

      if (!_lodash2.default.isObject(json) || _lodash2.default.isString(json) || _lodash2.default.isNumber(json) || _lodash2.default.isDate(json) || _lodash2.default.isArray(json) || _lodash2.default.isFunction(json) || _lodash2.default.isTypedArray(json) || _lodash2.default.isRegExp(json)) {

        throw new Error('You should only pass objects to $setJson method. ' + '$setJson method was given an invalid value ' + json);
      }

      if (!options.patch) {
        json = mergeWithDefaults(this.constructor.jsonSchema, json);
      }

      json = this.$parseJson(json, options);
      json = this.$validate(json, options);

      return this.$set(json);
    }

    /**
     * Sets the values from a JSON object in database format.
     *
     * Calls `this.$parseDatabaseJson()`.
     *
     * @param {Object} json
     *    The JSON object in database format.
     *
     * @returns {ModelBase} `this` for chaining.
     */

  }, {
    key: '$setDatabaseJson',
    value: function $setDatabaseJson() {
      var json = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      json = this.$parseDatabaseJson(json);

      for (var key in json) {
        this[key] = json[key];
      }

      return this;
    }

    /**
     * Sets the values from another model or object.
     *
     * Unlike $setJson, this doesn't call any `$parseJson` methods or validate the input.
     * This simply sets each value in the object to this object.
     *
     * @param {Object} obj
     * @returns {ModelBase} `this` for chaining.
     */

  }, {
    key: '$set',
    value: function $set(obj) {
      var self = this;

      _lodash2.default.each(obj, function (value, key) {
        if (key.charAt(0) !== '$' && !_lodash2.default.isFunction(value)) {
          self[key] = value;
        }
      });

      return this;
    }

    /**
     * Omits a set of properties.
     *
     * The selected properties are set to `undefined`. Note that this is done in-place.
     * Properties are set to undefined instead of deleting them for performance reasons
     * (V8 doesn't like delete).
     *
     * ```js
     * var json = person
     *   .fromJson({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .$omit('lastName')
     *   .toJSON();
     *
     * console.log(_.has(json, 'lastName')); // --> false
     * ```
     *
     * ```js
     * var json = person
     *   .fromJson({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .$omit(['lastName'])
     *   .toJSON();
     *
     * console.log(_.has(json, 'lastName')); // --> false
     * ```
     *
     * ```js
     * var json = person
     *   .fromJson({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .$omit({lastName: true})
     *   .toJSON();
     *
     * console.log(_.has(json, 'lastName')); // --> false
     * ```
     *
     * @param {string|Array.<string>|Object.<string, boolean>} keys
     * @returns {ModelBase} `this` for chaining.
     */

  }, {
    key: '$omit',
    value: function $omit() {
      if (arguments.length === 1 && _lodash2.default.isObject(arguments[0])) {
        var keys = arguments[0];

        if (_lodash2.default.isArray(keys)) {
          omitArray(this, keys);
        } else {
          omitObject(this, keys);
        }
      } else {
        omitArray(this, _lodash2.default.toArray(arguments));
      }

      return this;
    }

    /**
     * Picks a set of properties.
     *
     * All other properties but the selected ones are set to `undefined`. Note that
     * this is done in-place. Properties are set to undefined instead of deleting
     * them for performance reasons (V8 doesn't like delete).
     *
     * ```js
     * var json = person
     *   .fromJson({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .$pick('firstName', 'age')
     *   .toJSON();
     *
     * console.log(_.has(json, 'lastName')); // --> false
     * ```
     *
     * ```js
     * var json = person
     *   .fromJson({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .$pick(['firstName', 'age'])
     *   .toJSON();
     *
     * console.log(_.has(json, 'lastName')); // --> false
     * ```
     *
     * ```js
     * var json = person
     *   .fromJson({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .$pick({firstName: true, age: true})
     *   .toJSON();
     *
     * console.log(_.has(json, 'lastName')); // --> false
     * ```
     *
     * @param {string|Array.<string>|Object.<string, boolean>} keys
     * @returns {ModelBase} `this` for chaining.
     */

  }, {
    key: '$pick',
    value: function $pick() {
      if (arguments.length === 1 && _lodash2.default.isObject(arguments[0])) {
        var keys = arguments[0];

        if (_lodash2.default.isArray(keys)) {
          pickArray(this, keys);
        } else {
          pickObject(this, keys);
        }
      } else {
        pickArray(this, _lodash2.default.toArray(arguments));
      }

      return this;
    }

    /**
     * Returns the values of the given properties as an array.
     *
     * @param {Array.<string>} props
     * @return {Array.<*>}
     */

  }, {
    key: '$values',
    value: function $values() {
      var _this = this;

      if (arguments.length === 0) {
        return _lodash2.default.values(this);
      } else if (arguments.length === 1 && _lodash2.default.isArray(arguments[0])) {
        return _lodash2.default.map(arguments[0], function (prop) {
          return _this[prop];
        });
      } else {
        return _lodash2.default.map(arguments, function (prop) {
          return _this[prop];
        });
      }
    }

    /**
     * Returns a deep copy of this model.
     *
     * If this object has instances of ModelBase as properties (or arrays of them)
     * they are cloned using their `.$clone()` method.
     *
     * @return {ModelBase}
     */

  }, {
    key: '$clone',
    value: function $clone() {
      var clone = new this.constructor();

      _lodash2.default.each(this, function (value, key) {
        if (_lodash2.default.isObject(value)) {
          clone[key] = cloneObject(value);
        } else {
          clone[key] = value;
        }
      });

      return clone;
    }

    /**
     * @protected
     */

  }, {
    key: '$$toJson',
    value: function $$toJson(createDbJson, omit, pick) {
      var json = toJsonImpl(this, createDbJson, omit, pick);

      if (createDbJson) {
        return this.$formatDatabaseJson(json);
      } else {
        return this.$formatJson(json);
      }
    }

    /**
     * Makes the given constructor a subclass of this class.
     *
     * @param {function=} subclassConstructor
     * @return {function}
     */

  }], [{
    key: 'extend',
    value: function extend(subclassConstructor) {
      if (_lodash2.default.isEmpty(subclassConstructor.name)) {
        throw new Error('Each ModelBase subclass constructor must have a name');
      }

      (0, _classUtils.inherits)(subclassConstructor, this);
      return subclassConstructor;
    }

    /**
     * Creates a model instance from a JSON object.
     *
     * The object is checked against `jsonSchema` and an exception is thrown on failure.
     *
     * @param {Object=} json
     *    The JSON from which to create the model.
     *
     * @param {ModelOptions=} options
     *    Optional options.
     *
     * @returns {Model}
     *
     * @throws ValidationError
     *    If validation fails.
     */

  }, {
    key: 'fromJson',
    value: function fromJson(json, options) {
      var model = new this();
      model.$setJson(json || {}, options);
      return model;
    }

    /**
     * Creates a model instance from a JSON object in database format.
     *
     * @param {Object=} json
     *    The JSON from which to create the model.
     *
     * @returns {Model}
     */

  }, {
    key: 'fromDatabaseJson',
    value: function fromDatabaseJson(json) {
      var model = new this();
      model.$setDatabaseJson(json || {});
      return model;
    }

    /**
     * Omit implementation to use.
     *
     * The default just sets the property to undefined for performance reasons.
     * If the slight performance drop is not an issue for you, you can override
     * this method to delete the property instead.
     *
     * @param {Object} obj
     * @param {string} prop
     */

  }, {
    key: 'omitImpl',
    value: function omitImpl(obj, prop) {
      obj[prop] = undefined;
    }

    /**
     * @ignore
     * @param {string} columnName
     * @returns {string}
     */

  }, {
    key: 'columnNameToPropertyName',
    value: function columnNameToPropertyName(columnName) {
      var model = new this();
      var addedProps = _lodash2.default.keys(model.$parseDatabaseJson({}));

      var row = {};
      row[columnName] = null;

      var props = _lodash2.default.keys(_lodash2.default.omit(model.$parseDatabaseJson(row), addedProps));
      var propertyName = _lodash2.default.first(props);

      return propertyName || null;
    }

    /**
     * @ignore
     * @param {string} propertyName
     * @returns {string}
     */

  }, {
    key: 'propertyNameToColumnName',
    value: function propertyNameToColumnName(propertyName) {
      var model = new this();
      var addedCols = _lodash2.default.keys(model.$formatDatabaseJson({}));

      var obj = {};
      obj[propertyName] = null;

      var cols = _lodash2.default.keys(_lodash2.default.omit(model.$formatDatabaseJson(obj), addedCols));
      var columnName = _lodash2.default.first(cols);

      return columnName || null;
    }
  }]);
  return ModelBase;
}(), _class2.jsonSchema = null, _temp), (_applyDecoratedDescriptor(_class, 'columnNameToPropertyName', [_decorators.memoize], (0, _getOwnPropertyDescriptor2.default)(_class, 'columnNameToPropertyName'), _class), _applyDecoratedDescriptor(_class, 'propertyNameToColumnName', [_decorators.memoize], (0, _getOwnPropertyDescriptor2.default)(_class, 'propertyNameToColumnName'), _class)), _class);

/**
 * @private
 */

exports.default = ModelBase;
function mergeWithDefaults(jsonSchema, json) {
  var merged = null;

  if (!jsonSchema) {
    return json;
  }

  // Check each schema property for default value.
  for (var key in jsonSchema.properties) {
    var prop = jsonSchema.properties[key];

    if (!_lodash2.default.has(json, key) && _lodash2.default.has(prop, 'default')) {
      if (merged === null) {
        // Only take expensive clone if needed.
        merged = _lodash2.default.cloneDeep(json);
      }

      if (_lodash2.default.isObject(prop.default)) {
        merged[key] = _lodash2.default.cloneDeep(prop.default);
      } else {
        merged[key] = prop.default;
      }
    }
  }

  if (merged === null) {
    return json;
  } else {
    return merged;
  }
}

/**
 * @private
 */
function tryValidate(jsonSchema, json, options) {
  var required = undefined;

  try {
    if (options.patch) {
      required = jsonSchema.required;
      jsonSchema.required = [];
    }

    return _tv2.default.validateMultiple(json, jsonSchema);
  } finally {
    if (options.patch) {
      jsonSchema.required = required;
    }
  }
}

/**
 * @private
 */
function parseValidationError(report) {
  var errorHash = {};
  var index = 0;

  if (report.errors.length === 0) {
    return null;
  }

  for (var i = 0; i < report.errors.length; ++i) {
    var error = report.errors[i];
    var key = error.dataPath.split('/').slice(1).join('.');

    // Hack: The dataPath is empty for failed 'required' validations. We parse
    // the property name from the error message.
    if (!key && error.message.substring(0, 26) === 'Missing required property:') {
      key = error.message.split(':')[1].trim();
    }

    // If the validation failed because of extra properties, the key is an empty string. We
    // still want a unique error in the hash for each failure.
    if (!key) {
      key = (index++).toString();
    }

    errorHash[key] = error.message;
  }

  return new _ValidationError2.default(errorHash);
}

/**
 * @private
 */
function toJsonImpl(self, createDbJson, omit, pick) {
  var json = {};

  _lodash2.default.each(self, function (value, key) {
    if (key.charAt(0) !== '$' && !_lodash2.default.isFunction(value) && !_lodash2.default.isUndefined(value) && (!omit || !omit[key]) && (!pick || pick[key])) {

      if (_lodash2.default.isObject(value)) {
        json[key] = toJsonObject(value, createDbJson);
      } else {
        json[key] = value;
      }
    }
  });

  return json;
}

/**
 * @private
 */
function toJsonObject(value, createDbJson) {
  if (_lodash2.default.isArray(value)) {
    return toJsonArray(value, createDbJson);
  } else if (value instanceof ModelBase) {
    if (createDbJson) {
      return value.$toDatabaseJson();
    } else {
      return value.$toJson();
    }
  } else {
    return _lodash2.default.cloneDeep(value);
  }
}

/**
 * @private
 */
function toJsonArray(value, createDbJson) {
  return _lodash2.default.map(value, function (value) {
    return toJsonObject(value, createDbJson);
  });
}

/**
 * @private
 */
function cloneObject(value) {
  if (_lodash2.default.isArray(value)) {
    return cloneArray(value);
  } else if (value instanceof ModelBase) {
    return value.$clone();
  } else {
    return _lodash2.default.cloneDeep(value);
  }
}

/**
 * @private
 */
function cloneArray(value) {
  return _lodash2.default.map(value, cloneObject);
}

/**
 * @private
 */
function omitObject(model, keyObj) {
  var ModelClass = model.constructor;

  _lodash2.default.each(keyObj, function (value, key) {
    if (value && key.charAt(0) !== '$' && _lodash2.default.has(model, key)) {
      ModelClass.omitImpl(model, key);
    }
  });
}

/**
 * @private
 */
function omitArray(model, keys) {
  var ModelClass = model.constructor;

  _lodash2.default.each(keys, function (key) {
    if (key.charAt(0) !== '$' && _lodash2.default.has(model, key)) {
      ModelClass.omitImpl(model, key);
    }
  });
}

/**
 * @private
 */
function pickObject(model, keyObj) {
  var ModelClass = model.constructor;

  _lodash2.default.each(model, function (value, key) {
    if (key.charAt(0) !== '$' && !keyObj[key]) {
      ModelClass.omitImpl(model, key);
    }
  });
}

/**
 * @private
 */
function pickArray(model, keys) {
  var ModelClass = model.constructor;

  _lodash2.default.each(model, function (value, key) {
    if (key.charAt(0) !== '$' && !contains(keys, key)) {
      ModelClass.omitImpl(model, key);
    }
  });
}

/**
 * @private
 */
function contains(arr, value) {
  for (var i = 0, l = arr.length; i < l; ++i) {
    if (arr[i] === value) {
      return true;
    }
  }
  return false;
}

// Add validation formats, so that for example the following schema validation works:
// createTime: {type: 'string', format: 'date-time'}
_tv2.default.addFormat(_tv4Formats2.default);