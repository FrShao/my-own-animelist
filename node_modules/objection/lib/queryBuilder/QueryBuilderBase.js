'use strict';

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _dec61, _dec62, _dec63, _dec64, _dec65, _dec66, _dec67, _dec68, _dec69, _dec70, _dec71, _dec72, _dec73, _dec74, _dec75, _dec76, _class, _desc, _value, _class2;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _jsonFieldExpressionParser = require('./parsers/jsonFieldExpressionParser');

var _jsonFieldExpressionParser2 = _interopRequireDefault(_jsonFieldExpressionParser);

var _InsertionOrUpdate = require('./InsertionOrUpdate');

var _InsertionOrUpdate2 = _interopRequireDefault(_InsertionOrUpdate);

var _classUtils = require('../utils/classUtils');

var _dbUtils = require('../utils/dbUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Knex query builder wrapper.
 *
 * This class is a thin wrapper around knex query builder. This class allows us to add our own
 * query builder methods without monkey patching knex query builder.
 *
 * @constructor
 * @ignore
 */
var QueryBuilderBase = (_dec = (0, _dbUtils.overwriteForDatabase)(), _dec2 = knexQueryMethod(), _dec3 = knexQueryMethod(), _dec4 = knexQueryMethod(), _dec5 = knexQueryMethod('delete'), _dec6 = knexQueryMethod(), _dec7 = knexQueryMethod(), _dec8 = knexQueryMethod(), _dec9 = knexQueryMethod(), _dec10 = knexQueryMethod(), _dec11 = knexQueryMethod(), _dec12 = knexQueryMethod(), _dec13 = knexQueryMethod(), _dec14 = knexQueryMethod(), _dec15 = knexQueryMethod(), _dec16 = knexQueryMethod(), _dec17 = knexQueryMethod(), _dec18 = knexQueryMethod(), _dec19 = knexQueryMethod(), _dec20 = knexQueryMethod(), _dec21 = knexQueryMethod(), _dec22 = knexQueryMethod(), _dec23 = knexQueryMethod(), _dec24 = knexQueryMethod(), _dec25 = knexQueryMethod(), _dec26 = knexQueryMethod(), _dec27 = knexQueryMethod(), _dec28 = knexQueryMethod(), _dec29 = knexQueryMethod(), _dec30 = knexQueryMethod(), _dec31 = knexQueryMethod(), _dec32 = knexQueryMethod(), _dec33 = knexQueryMethod(), _dec34 = knexQueryMethod(), _dec35 = knexQueryMethod(), _dec36 = knexQueryMethod(), _dec37 = knexQueryMethod(), _dec38 = knexQueryMethod(), _dec39 = knexQueryMethod(), _dec40 = knexQueryMethod(), _dec41 = knexQueryMethod(), _dec42 = knexQueryMethod(), _dec43 = knexQueryMethod(), _dec44 = knexQueryMethod(), _dec45 = knexQueryMethod(), _dec46 = knexQueryMethod(), _dec47 = knexQueryMethod(), _dec48 = knexQueryMethod(), _dec49 = knexQueryMethod(), _dec50 = knexQueryMethod(), _dec51 = knexQueryMethod(), _dec52 = knexQueryMethod(), _dec53 = knexQueryMethod(), _dec54 = knexQueryMethod(), _dec55 = knexQueryMethod(), _dec56 = knexQueryMethod(), _dec57 = knexQueryMethod(), _dec58 = knexQueryMethod(), _dec59 = knexQueryMethod(), _dec60 = knexQueryMethod(), _dec61 = knexQueryMethod(), _dec62 = knexQueryMethod(), _dec63 = knexQueryMethod(), _dec64 = knexQueryMethod(), _dec65 = knexQueryMethod(), _dec66 = knexQueryMethod(), _dec67 = knexQueryMethod(), _dec68 = knexQueryMethod(), _dec69 = knexQueryMethod(), _dec70 = knexQueryMethod(), _dec71 = knexQueryMethod(), _dec72 = knexQueryMethod(), _dec73 = knexQueryMethod(), _dec74 = knexQueryMethod(), _dec75 = knexQueryMethod(), _dec76 = (0, _dbUtils.overwriteForDatabase)({
  sqlite3: 'whereInComposite_sqlite3'
}), _dec(_class = (_class2 = function () {
  function QueryBuilderBase(knex) {
    (0, _classCallCheck3.default)(this, QueryBuilderBase);

    this._knex = knex;
    this._knexMethodCalls = [];
    this._context = {};
  }

  /**
   * Makes the given constructor a subclass of this class.
   *
   * @param {function=} subclassConstructor
   * @return {Class.<QueryBuilderBase>}
   */

  (0, _createClass3.default)(QueryBuilderBase, [{
    key: 'context',

    /**
     * Sets/gets the query context.
     */
    value: function context() {
      if (arguments.length === 0) {
        return this._context.userContext;
      } else {
        this._context.userContext = arguments[0];
        return this;
      }
    }

    /**
     * Sets/gets the query full internal context.
     *
     * For internal use only.
     *
     * @ignore
     */

  }, {
    key: 'internalContext',
    value: function internalContext() {
      if (arguments.length === 0) {
        return this._context;
      } else {
        this._context = arguments[0];
        return this;
      }
    }

    /**
     * Returns the knex connection passed to the constructor.
     *
     * @ignore
     */

  }, {
    key: 'knex',
    value: function knex() {
      return this._knex;
    }

    /**
     * Calls the given function immediately and passes `this` as an argument.
     *
     * Handy for chaining conditional stuff:
     *
     * ```js
     * new QueryBuilderBase().call(function (builder) {
     *   if (someCondition) {
     *     builder.where('something', someValue);
     *   }
     * });
     * ```
     *
     * @param {function} func
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'call',
    value: function call(func) {
      func.call(this, this);
      return this;
    }

    /**
     * Returns the SQL string.
     *
     * @returns {string}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.build().toString();
    }

    /**
     * Returns the SQL string.
     *
     * @returns {string}
     */

  }, {
    key: 'toSql',
    value: function toSql() {
      return this.toString();
    }

    /**
     * Create a clone of this builder.
     *
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'clone',
    value: function clone() {
      var clone = new this.constructor(this._knex);
      this.cloneInto(clone);
      return clone;
    }

    /**
     * @protected
     */

  }, {
    key: 'cloneInto',
    value: function cloneInto(builder) {
      builder._knex = this._knex;
      builder._knexMethodCalls = this._knexMethodCalls.slice();
      builder._context = this._context;
    }

    /**
     * Removes query builder method calls.
     *
     * @param {RegExp=} methodNameRegex
     *    Optional patter to that must match the method names to remove.
     *    If not given, all calls are removed.
     *
     * @ignore
     */

  }, {
    key: 'clear',
    value: function clear(methodNameRegex) {
      if (methodNameRegex) {
        // Reject all query method calls that don't pass the filter.
        this._knexMethodCalls = _lodash2.default.reject(this._knexMethodCalls, function (call) {
          return methodNameRegex.test(call.method);
        });
      } else {
        // If no arguments are given, clear all query method calls.
        this._knexMethodCalls = [];
      }

      return this;
    }

    /**
     * Copy query builder method calls from another query builder.
     *
     * @param {QueryBuilderBase} queryBuilder
     *    The builder to copy from.
     *
     * @param {RegExp} methodNameRegex
     *    Optional regular expression to filter which method calls are copied.
     *
     * @ignore
     */

  }, {
    key: 'copyFrom',
    value: function copyFrom(queryBuilder, methodNameRegex) {
      var self = this;

      _lodash2.default.forEach(queryBuilder._knexMethodCalls, function (call) {
        if (!methodNameRegex || methodNameRegex.test(call.method)) {
          self._knexMethodCalls.push(call);
        }
      });

      return this;
    }

    /**
     * Returns true if the builder has a call to a method whose name matches the `methodNameRegex`.
     *
     * @param {RegExp} methodNameRegex
     *
     * @ignore
     */

  }, {
    key: 'has',
    value: function has(methodNameRegex) {
      return _lodash2.default.any(this._knexMethodCalls, function (call) {
        return methodNameRegex.test(call.method);
      });
    }

    /**
     * Builds the query into a knex query builder.
     *
     * @returns {knex.QueryBuilder}
     *    The built knex query builder.
     *
     * @protected
     */

  }, {
    key: 'build',
    value: function build() {
      return this.buildInto(this._knex.queryBuilder());
    }

    /**
     * @private
     */

  }, {
    key: 'buildInto',
    value: function buildInto(knexBuilder) {
      _lodash2.default.forEach(this._knexMethodCalls, function (call) {
        if (_lodash2.default.isFunction(knexBuilder[call.method])) {
          knexBuilder[call.method].apply(knexBuilder, call.args);
        }
      });

      return knexBuilder;
    }

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'insert',
    value: function insert() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'update',
    value: function update() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'delete',
    value: function _delete() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'del',
    value: function del() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'select',
    value: function select() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'forUpdate',
    value: function forUpdate() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'forShare',
    value: function forShare() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'as',
    value: function as() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'columns',
    value: function columns() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'column',
    value: function column() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'from',
    value: function from() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'fromJS',
    value: function fromJS() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'into',
    value: function into() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'withSchema',
    value: function withSchema() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'table',
    value: function table() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'distinct',
    value: function distinct() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'join',
    value: function join() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'joinRaw',
    value: function joinRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'innerJoin',
    value: function innerJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'leftJoin',
    value: function leftJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'leftOuterJoin',
    value: function leftOuterJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'rightJoin',
    value: function rightJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'rightOuterJoin',
    value: function rightOuterJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'outerJoin',
    value: function outerJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'fullOuterJoin',
    value: function fullOuterJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'crossJoin',
    value: function crossJoin() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'where',
    value: function where() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'andWhere',
    value: function andWhere() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhere',
    value: function orWhere() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereNot',
    value: function whereNot() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereNot',
    value: function orWhereNot() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereRaw',
    value: function whereRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereWrapped',
    value: function whereWrapped() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'havingWrapped',
    value: function havingWrapped() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereRaw',
    value: function orWhereRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereExists',
    value: function whereExists() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereExists',
    value: function orWhereExists() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereNotExists',
    value: function whereNotExists() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereNotExists',
    value: function orWhereNotExists() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereIn',
    value: function whereIn() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereIn',
    value: function orWhereIn() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereNotIn',
    value: function whereNotIn() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     */

  }, {
    key: 'orWhereNotIn',
    value: function orWhereNotIn() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereNull',
    value: function whereNull() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereNull',
    value: function orWhereNull() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereNotNull',
    value: function whereNotNull() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereNotNull',
    value: function orWhereNotNull() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereBetween',
    value: function whereBetween() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereNotBetween',
    value: function whereNotBetween() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereBetween',
    value: function orWhereBetween() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orWhereNotBetween',
    value: function orWhereNotBetween() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'groupBy',
    value: function groupBy() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'groupByRaw',
    value: function groupByRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orderBy',
    value: function orderBy() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orderByRaw',
    value: function orderByRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'union',
    value: function union() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'unionAll',
    value: function unionAll() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'having',
    value: function having() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'havingRaw',
    value: function havingRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orHaving',
    value: function orHaving() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'orHavingRaw',
    value: function orHavingRaw() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'offset',
    value: function offset() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'limit',
    value: function limit() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'count',
    value: function count() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'countDistinct',
    value: function countDistinct() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'min',
    value: function min() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'max',
    value: function max() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'sum',
    value: function sum() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'avg',
    value: function avg() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'avgDistinct',
    value: function avgDistinct() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'debug',
    value: function debug() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'returning',
    value: function returning() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'truncate',
    value: function truncate() {}

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'connection',
    value: function connection() {}

    /**
     * Compares a column reference to another
     *
     * ```js
     * builder.whereRef('Person.id', '=', 'Animal.ownerId');
     * ```
     */

  }, {
    key: 'whereRef',
    value: function whereRef(lhs, op, rhs) {
      return this._whereRef('and', lhs, op, rhs);
    }

    /**
     * Compares a column reference to another
     *
     * ```js
     * builder.orWhereRef('Person.id', '=', 'Animal.ownerId');
     * ```
     */

  }, {
    key: 'orWhereRef',
    value: function orWhereRef(lhs, op, rhs) {
      return this._whereRef('or', lhs, op, rhs);
    }

    /**
     * `where` for (possibly) composite keys.
     *
     * ```js
     * builder.whereComposite(['id', 'name'], [1, 'Jennifer']);
     * ```
     *
     * ```js
     * builder.whereComposite('id', '=', 1);
     * ```
     *
     * @param {string|Array.<string>} cols
     * @param {string|*|Array.<*>} op
     * @param {*|Array.<*>=} values
     *
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereComposite',
    value: function whereComposite(cols, op, values) {
      var _this = this;

      if (_lodash2.default.isUndefined(values)) {
        values = op;
        op = '=';
      }

      var colsIsArray = _lodash2.default.isArray(cols);
      var valuesIsArray = _lodash2.default.isArray(values);

      if (!colsIsArray && !valuesIsArray) {
        return this.where(cols, op, values);
      } else if (colsIsArray && cols.length === 1 && !valuesIsArray) {
        return this.where(cols[0], op, values);
      } else if (colsIsArray && valuesIsArray && cols.length === values.length) {
        _lodash2.default.each(cols, function (col, idx) {
          return _this.where(col, op, values[idx]);
        });
        return this;
      } else {
        throw new Error('both cols and values must have same dimensions');
      }
    }

    /**
     * `whereIn` for (possibly) composite keys.
     *
     *
     * ```js
     * builder.whereInComposite(['a', 'b'], [[1, 2], [3, 4], [1, 4]]);
     * ```
     *
     * ```js
     * builder.whereInComposite('a', [[1], [3], [1]]);
     * ```
     *
     * ```js
     * builder.whereInComposite('a', [1, 3, 1]);
     * ```
     *
     * ```js
     * builder.whereInComposite(['a', 'b'], SomeModel.query().select('a', 'b'));
     * ```
     *
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereInComposite',
    value: function whereInComposite(columns, values) {
      var _this2 = this;

      var isCompositeKey = _lodash2.default.isArray(columns) && columns.length > 1;

      if (isCompositeKey) {
        if (_lodash2.default.isArray(values)) {
          return this.whereIn(columns, values);
        } else {
          var _ret = function () {
            // Because of a bug in knex, we need to build the where-in query from pieces
            // if the value is a subquery.
            var formatter = _this2._knex.client.formatter();
            var sql = '(' + _lodash2.default.map(columns, function (col) {
              return formatter.wrap(col);
            }).join() + ')';
            return {
              v: _this2.whereIn(_this2._knex.raw(sql), values)
            };
          }();

          if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
        }
      } else {
        var col = _lodash2.default.isString(columns) ? columns : columns[0];

        if (_lodash2.default.isArray(values)) {
          values = _lodash2.default.compact(_lodash2.default.flatten(values));
        }

        // For non-composite keys we can use the normal whereIn.
        return this.whereIn(col, values);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'whereInComposite_sqlite3',
    value: function whereInComposite_sqlite3(columns, values) {
      var isCompositeKey = _lodash2.default.isArray(columns) && columns.length > 1;

      if (isCompositeKey) {
        if (!_lodash2.default.isArray(values)) {
          // If the `values` is not an array of values but a function or a subquery
          // we have no way to implement this method.
          throw new Error('sqlite doesn\'t support multi-column where in clauses');
        }

        // Sqlite doesn't support the `where in` syntax for multiple columns but
        // we can emulate it using grouped `or` clauses.
        return this.where(function (builder) {
          _lodash2.default.each(values, function (val) {
            builder.orWhere(function (builder) {
              _lodash2.default.each(columns, function (col, idx) {
                builder.andWhere(col, val[idx]);
              });
            });
          });
        });
      } else {
        var col = _lodash2.default.isString(columns) ? columns : columns[0];

        if (_lodash2.default.isArray(values)) {
          values = _lodash2.default.compact(_lodash2.default.flatten(values));
        }

        // For non-composite keys we can use the normal whereIn.
        return this.whereIn(col, values);
      }
    }

    /**
     * Json query APIs
     */

    /**
     * @typedef {String} FieldExpression
     *
     * Field expressions allow one to refer to separate JSONB fields inside columns.
     *
     * Syntax: <column reference>[:<json field reference>]
     *
     * e.g. `Person.jsonColumnName:details.names[1]` would refer to value `'Second'`
     * in column `Person.jsonColumnName` which has
     * `{ details: { names: ['First', 'Second', 'Last'] } }` object stored in it.
     *
     * First part `<column reference>` is compatible with column references used in
     * knex e.g. `MyFancyTable.tributeToThBestColumnNameEver`.
     *
     * Second part describes a path to an attribute inside the referred column.
     * It is optional and it always starts with colon which follows directly with
     * first path element. e.g. `Table.jsonObjectColumnName:jsonFieldName` or
     * `Table.jsonArrayColumn:[321]`.
     *
     * Syntax supports `[<key or index>]` and `.<key or index>` flavors of reference
     * to json keys / array indexes:
     *
     * e.g. both `Table.myColumn:[1][3]` and `Table.myColumn:1.3` would access correctly
     * both of the following objects `[null, [null,null,null, "I was accessed"]]` and
     * `{ "1": { "3" : "I was accessed" } }`
     *
     * Caveats when using special characters in keys:
     *
     * 1. `objectColumn.key` This is the most common syntax, good if you are
     *    not using dots or square brackets `[]` in your json object key name.
     * 2. Keys containing dots `objectColumn:[keywith.dots]` Column `{ "keywith.dots" : "I was referred" }`
     * 3. Keys containing square brackets `column['[]']` `{ "[]" : "This is getting ridiculous..." }`
     * 4. Keys containing square brackets and quotes
     *    `objectColumn:['Double."Quote".[]']` and `objectColumn:["Sinlge.'Quote'.[]"]`
     *    Column `{ "Double.\"Quote\".[]" : "I was referred",  "Sinlge.'Quote'.[]" : "Mee too!" }`
     * 99. Keys containing dots, square brackets, single quotes and double quotes in one json key is
     *     not currently supported
     */

    /**
     * Where jsonb field reference equals jsonb object or other field reference.
     *
     * Also supports having field expression in both sides of equality.
     *
     * ```js
     * Person
     *   .query()
     *   .whereJsonEquals('additionalData:myDogs', 'additionalData:dogsAtHome')
     *   .then(function (people) {
     *     // oh joy! these people have all their dogs at home!
     *   });
     *
     * Person
     *   .query()
     *   .whereJsonEquals('additionalData:myDogs[0]', { name: "peter"})
     *   .then(function (people) {
     *     // these people's first dog name is "peter" and the dog has no other
     *     // attributes, but its name
     *   });
     * ```
     *
     * @param {FieldExpression} fieldExpression
     *    Reference to column / json field.
     *
     * @param {Object|Array|FieldExpression} jsonObjectOrFieldExpression
     *    Reference to column / json field or json object.
     *
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonEquals',
    value: function whereJsonEquals(fieldExpression, jsonObjectOrFieldExpression) {
      return whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "=", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonEquals}
     */

  }, {
    key: 'orWhereJsonEquals',
    value: function orWhereJsonEquals(fieldExpression, jsonObjectOrFieldExpression) {
      return orWhereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "=", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonEquals}
     */

  }, {
    key: 'whereJsonNotEquals',
    value: function whereJsonNotEquals(fieldExpression, jsonObjectOrFieldExpression) {
      return whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "!=", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonEquals}
     */

  }, {
    key: 'orWhereJsonNotEquals',
    value: function orWhereJsonNotEquals(fieldExpression, jsonObjectOrFieldExpression) {
      return orWhereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "!=", jsonObjectOrFieldExpression);
    }

    /**
     * Where left hand json field reference is a superset of the right hand json value or reference.
     *
     * ```js
     * Person
     *   .query()
     *   .whereJsonSupersetOf('additionalData:myDogs', 'additionalData:dogsAtHome')
     *   .then(function (people) {
     *     // These people have all or some of their dogs at home. Person might have some
     *     // additional dogs in their custody since myDogs is superset of dogsAtHome.
     *   });
     *
     * Person
     *   .query()
     *   .whereJsonSupersetOf('additionalData:myDogs[0]', { name: "peter"})
     *   .then(function (people) {
     *     // These people's first dog name is "peter", but the dog might have
     *     // additional attributes as well.
     *   });
     * ```
     *
     * Object and array are always their own supersets.
     *
     * For arrays this means that left side matches if it has all the elements
     * listed in the right hand side. e.g.
     *
     * ```
     * [1,2,3] isSuperSetOf [2] => true
     * [1,2,3] isSuperSetOf [2,1,3] => true
     * [1,2,3] isSuperSetOf [2,null] => false
     * [1,2,3] isSuperSetOf [] => true
     * ```
     *
     * The `not` variants with jsonb operators behave in a way that they won't match rows, which don't have
     * the referred json key referred in field expression. e.g. for table
     *
     * ```
     *  id |    jsonObject
     * ----+--------------------------
     *   1 | {}
     *   2 | NULL
     *   3 | {"a": 1}
     *   4 | {"a": 1, "b": 2}
     *   5 | {"a": ['3'], "b": ['3']}
     * ```
     *
     * query:
     *
     * ```js
     * builder.whereJsonNotEquals("jsonObject:a", "jsonObject:b")
     * ```
     *
     * Returns only the row `4` which has keys `a` and `b` and `a` != `b`, but it won't return any rows which
     * does not have `jsonObject.a` or `jsonObject.b`.
     *
     * @param {FieldExpression} fieldExpression
     *    Reference to column / json field, which is tested for being a superset.
     *
     * @param {Object|Array|FieldExpression} jsonObjectOrFieldExpression
     *    To which to compare.
     *
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonSupersetOf',
    value: function whereJsonSupersetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonSupersetOf}
     */

  }, {
    key: 'orWhereJsonSupersetOf',
    value: function orWhereJsonSupersetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return orWhereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonSupersetOf}
     */

  }, {
    key: 'whereJsonNotSupersetOf',
    value: function whereJsonNotSupersetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", jsonObjectOrFieldExpression, 'not');
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonSupersetOf}
     */

  }, {
    key: 'orWhereJsonNotSupersetOf',
    value: function orWhereJsonNotSupersetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return orWhereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", jsonObjectOrFieldExpression, 'not');
    }

    /**
     * Where left hand json field reference is a subset of the right hand json value or reference.
     *
     * Object and array are always their own subsets.
     *
     * @see {@link QueryBuilderBase#whereJsonSupersetOf}
     *
     * @param {FieldExpression} fieldExpression
     * @param {Object|Array|FieldExpression} jsonObjectOrFieldExpression
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonSubsetOf',
    value: function whereJsonSubsetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "<@", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonSubsetOf}
     */

  }, {
    key: 'orWhereJsonSubsetOf',
    value: function orWhereJsonSubsetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return orWhereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "<@", jsonObjectOrFieldExpression);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonSubsetOf}
     */

  }, {
    key: 'whereJsonNotSubsetOf',
    value: function whereJsonNotSubsetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "<@", jsonObjectOrFieldExpression, 'not');
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonSubsetOf}
     */

  }, {
    key: 'orWhereJsonNotSubsetOf',
    value: function orWhereJsonNotSubsetOf(fieldExpression, jsonObjectOrFieldExpression) {
      return orWhereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "<@", jsonObjectOrFieldExpression, 'not');
    }

    /**
     * Where json field reference is an array.
     *
     * @param {FieldExpression} fieldExpression
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonIsArray',
    value: function whereJsonIsArray(fieldExpression) {
      return this.whereJsonSupersetOf(fieldExpression, []);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonIsArray}
     */

  }, {
    key: 'orWhereJsonIsArray',
    value: function orWhereJsonIsArray(fieldExpression) {
      return this.orWhereJsonSupersetOf(fieldExpression, []);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonIsArray}
     * @note Also returns rows where `fieldExpression` does not exist.
     */

  }, {
    key: 'whereJsonNotArray',
    value: function whereJsonNotArray(fieldExpression) {
      var knex = this._knex;
      // uhh... ugly. own subquery builder could help... now this refers to plain knex subquery builder
      return this.where(function () {
        // not array
        var builder = whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", [], 'not');
        var ifRefNotExistQuery = whereJsonFieldQuery(knex, fieldExpression, "IS", null);
        // or not exist
        builder.orWhereRaw(ifRefNotExistQuery);
      });
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonIsArray}
     * @note Also returns rows where `fieldExpression` does not exist.
     */

  }, {
    key: 'orWhereJsonNotArray',
    value: function orWhereJsonNotArray(fieldExpression) {
      var knex = this._knex;
      return this.orWhere(function () {
        // not array
        var builder = whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", [], 'not');
        var ifRefNotExistQuery = whereJsonFieldQuery(knex, fieldExpression, "IS", null);
        // or not exist
        builder.orWhereRaw(ifRefNotExistQuery);
      });
    }

    /**
     * Where json field reference is an object.
     *
     * @param {FieldExpression} fieldExpression
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonIsObject',
    value: function whereJsonIsObject(fieldExpression) {
      return this.whereJsonSupersetOf(fieldExpression, {});
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonIsObject}
     */

  }, {
    key: 'orWhereJsonIsObject',
    value: function orWhereJsonIsObject(fieldExpression) {
      return this.orWhereJsonSupersetOf(fieldExpression, {});
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonIsObject}
     * @note Also returns rows where `fieldExpression` does not exist.
     */

  }, {
    key: 'whereJsonNotObject',
    value: function whereJsonNotObject(fieldExpression) {
      var knex = this._knex;
      return this.where(function () {
        // not object
        var builder = whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", {}, 'not');
        var ifRefNotExistQuery = whereJsonFieldQuery(knex, fieldExpression, "IS", null);
        // or not exist
        builder.orWhereRaw(ifRefNotExistQuery);
      });
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonIsObject}
     * @note Also returns rows where `fieldExpression` does not exist.
     */

  }, {
    key: 'orWhereJsonNotObject',
    value: function orWhereJsonNotObject(fieldExpression) {
      var knex = this._knex;
      return this.orWhere(function () {
        // not object
        var builder = whereJsonbRefOnLeftJsonbValOrRefOnRight(this, fieldExpression, "@>", {}, 'not');
        var ifRefNotExistQuery = whereJsonFieldQuery(knex, fieldExpression, "IS", null);
        // or not exist
        builder.orWhereRaw(ifRefNotExistQuery);
      });
    }

    /**
     * Where any of given strings is found from json object key(s) or array items.
     *
     * @param {FieldExpression} fieldExpression
     * @param {string|Array.<string>} keys Strings that are looked from object or array.
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonHasAny',
    value: function whereJsonHasAny(fieldExpression, keys) {
      return whereJsonFieldRightStringArrayOnLeft(this, fieldExpression, '?|', keys);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonHasAny}
     */

  }, {
    key: 'orWhereJsonHasAny',
    value: function orWhereJsonHasAny(fieldExpression, keys) {
      return orWhereJsonFieldRightStringArrayOnLeft(this, fieldExpression, '?|', keys);
    }

    /**
     * Where all of given strings are found from json object key(s) or array items.
     *
     * @param {FieldExpression} fieldExpression
     * @param {string|Array.<string>} keys Strings that are looked from object or array.
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonHasAll',
    value: function whereJsonHasAll(fieldExpression, keys) {
      return whereJsonFieldRightStringArrayOnLeft(this, fieldExpression, '?&', keys);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonHasAll}
     */

  }, {
    key: 'orWhereJsonHasAll',
    value: function orWhereJsonHasAll(fieldExpression, keys) {
      return orWhereJsonFieldRightStringArrayOnLeft(this, fieldExpression, '?&', keys);
    }

    /**
     * Where referred json field value casted to same type with value fulfill given operand.
     *
     * Value may be number, string, null, boolean and referred json field is converted
     * to TEXT, NUMERIC or BOOLEAN sql type for comparison.
     *
     * If left hand field does not exist rows appear IS null so if one needs to get only
     * rows, which has key and it's value is null one may use e.g.
     * `.whereJsonSupersetOf("column", { field: null })` or check is key exist and
     * then `.whereJsonField('column:field', 'IS', null)`
     *
     * For testing against objects or arrays one should see tested with whereJsonEqual,
     * whereJsonSupersetOf and whereJsonSubsetOf methods.
     *
     * @param {FieldExpression} fieldExpression Expression pointing to certain value.
     * @param {string} operator SQL comparator usually `<`, `>`, `<>`, `=` or `!=`
     * @param {boolean|Number|string|null} value Value to which field is compared to.
     * @returns {QueryBuilderBase}
     */

  }, {
    key: 'whereJsonField',
    value: function whereJsonField(fieldExpression, operator, value) {
      var query = whereJsonFieldQuery(this._knex, fieldExpression, operator, value);
      return this.whereRaw(query);
    }

    /**
     * @see {@link QueryBuilderBase#whereJsonField}
     */

  }, {
    key: 'orWhereJsonField',
    value: function orWhereJsonField(fieldExpression, operator, value) {
      var query = whereJsonFieldQuery(this._knex, fieldExpression, operator, value);
      return this.orWhereRaw(query);
    }

    /**
     * @private
     */

  }, {
    key: '_whereRef',
    value: function _whereRef(bool, lhs, op, rhs) {
      if (!rhs) {
        rhs = op;
        op = '=';
      }

      var formatter = this._knex.client.formatter();
      op = formatter.operator(op);

      if (!_lodash2.default.isString(lhs) || !_lodash2.default.isString(rhs) || !_lodash2.default.isString(op)) {
        throw new Error('whereRef: invalid operands or operator');
      }

      var sql = formatter.wrap(lhs) + ' ' + op + ' ' + formatter.wrap(rhs);
      if (bool === 'or') {
        return this.orWhereRaw(sql);
      } else {
        return this.whereRaw(sql);
      }
    }
  }], [{
    key: 'extend',
    value: function extend(subclassConstructor) {
      (0, _classUtils.inherits)(subclassConstructor, this);
      return subclassConstructor;
    }
  }]);
  return QueryBuilderBase;
}(), (_applyDecoratedDescriptor(_class2.prototype, 'insert', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'insert'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'update', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'update'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'delete', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'delete'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'del', [_dec5], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'del'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'select', [_dec6], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'select'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'forUpdate', [_dec7], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'forUpdate'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'forShare', [_dec8], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'forShare'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'as', [_dec9], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'as'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'columns', [_dec10], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'columns'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'column', [_dec11], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'column'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'from', [_dec12], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'from'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'fromJS', [_dec13], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'fromJS'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'into', [_dec14], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'into'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'withSchema', [_dec15], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'withSchema'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'table', [_dec16], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'table'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'distinct', [_dec17], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'distinct'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'join', [_dec18], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'join'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'joinRaw', [_dec19], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'joinRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'innerJoin', [_dec20], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'innerJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'leftJoin', [_dec21], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'leftJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'leftOuterJoin', [_dec22], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'leftOuterJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'rightJoin', [_dec23], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'rightJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'rightOuterJoin', [_dec24], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'rightOuterJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'outerJoin', [_dec25], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'outerJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'fullOuterJoin', [_dec26], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'fullOuterJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'crossJoin', [_dec27], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'crossJoin'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'where', [_dec28], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'where'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'andWhere', [_dec29], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'andWhere'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhere', [_dec30], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhere'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereNot', [_dec31], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereNot'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereNot', [_dec32], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereNot'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereRaw', [_dec33], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereWrapped', [_dec34], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereWrapped'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'havingWrapped', [_dec35], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'havingWrapped'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereRaw', [_dec36], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereExists', [_dec37], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereExists'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereExists', [_dec38], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereExists'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereNotExists', [_dec39], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereNotExists'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereNotExists', [_dec40], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereNotExists'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereIn', [_dec41], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereIn'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereIn', [_dec42], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereIn'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereNotIn', [_dec43], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereNotIn'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereNotIn', [_dec44], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereNotIn'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereNull', [_dec45], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereNull'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereNull', [_dec46], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereNull'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereNotNull', [_dec47], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereNotNull'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereNotNull', [_dec48], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereNotNull'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereBetween', [_dec49], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereBetween'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereNotBetween', [_dec50], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereNotBetween'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereBetween', [_dec51], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereBetween'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orWhereNotBetween', [_dec52], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orWhereNotBetween'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'groupBy', [_dec53], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'groupBy'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'groupByRaw', [_dec54], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'groupByRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orderBy', [_dec55], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orderBy'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orderByRaw', [_dec56], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orderByRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'union', [_dec57], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'union'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'unionAll', [_dec58], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'unionAll'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'having', [_dec59], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'having'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'havingRaw', [_dec60], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'havingRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orHaving', [_dec61], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orHaving'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'orHavingRaw', [_dec62], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'orHavingRaw'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'offset', [_dec63], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'offset'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'limit', [_dec64], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'limit'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'count', [_dec65], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'count'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'countDistinct', [_dec66], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'countDistinct'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'min', [_dec67], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'min'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'max', [_dec68], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'max'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'sum', [_dec69], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'sum'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'avg', [_dec70], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'avg'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'avgDistinct', [_dec71], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'avgDistinct'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'debug', [_dec72], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'debug'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'returning', [_dec73], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'returning'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'truncate', [_dec74], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'truncate'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'connection', [_dec75], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'connection'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'whereInComposite', [_dec76], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, 'whereInComposite'), _class2.prototype)), _class2)) || _class);

/**
 * @private
 */

exports.default = QueryBuilderBase;
function knexQueryMethod(overrideMethodName) {
  return function (target, methodName, descriptor) {
    descriptor.value = function () {
      var args = new Array(arguments.length);
      var context = this.internalContext();

      for (var i = 0, l = arguments.length; i < l; ++i) {
        if (_lodash2.default.isUndefined(arguments[i])) {
          // None of the query builder methods should accept undefined. Do nothing if
          // one of the arguments is undefined. This enables us to do things like
          // `.where('name', req.query.name)` without checking if req.query has the
          // property `name`.
          return this;
        } else if (arguments[i] instanceof QueryBuilderBase) {
          // Convert QueryBuilderBase instances into knex query builders.
          args[i] = arguments[i].internalContext(context).build();
        } else if (_lodash2.default.isFunction(arguments[i])) {
          // If an argument is a function, knex calls it with a query builder as
          // `this` context. We call the function with a QueryBuilderBase as
          // `this` context instead.
          args[i] = wrapFunctionArg(arguments[i], this);
        } else {
          args[i] = arguments[i];
        }
      }

      this._knexMethodCalls.push({
        method: overrideMethodName || methodName,
        args: args
      });

      return this;
    };
  };
}

/**
 * @private
 */
function wrapFunctionArg(func, query) {
  return function () {
    if ((0, _dbUtils.isKnexQueryBuilder)(this)) {
      var context = query.internalContext();
      var builder = new QueryBuilderBase(query._knex).internalContext(context);
      func.call(builder, builder);
      builder.buildInto(this);
    } else {
      return func.apply(this, arguments);
    }
  };
}

/**
 * Parses a objection.js json field expression into a postgres jsonb field reference.
 *
 * For example, assume we have this object stored in the column `jsonColumn` of a table `Table`:
 *
 * ```
 * {obj: { "key.with.dots": [{"key": { "0": { me : [ "I was referred" ] } } } ] } }
 * ```
 *
 * We can refer to the value "I was referred" using the following field expression:
 *
 * ```
 * Table.jsonColumn:obj[key.with.dots][0].key.0.me[0]
 * ```
 *
 * Since Postgresql #>{field,0,field2,...} operator does not make difference if
 * reference is string or a number, one can actually use also jsonArray.0 notation
 * to refer index of an array. Like wise one can use object[123] notation to refer
 * key of an object { "123" : null }.
 *
 * @private
 * @param {string} expression
 * @param {boolean} extractAsText Return text instead of jsonb object (useful for type casting).
 * @returns {string} postgres json reference.
 */
function parseFieldExpression(expression, extractAsText) {
  var parsed = _jsonFieldExpressionParser2.default.parse(expression);
  var jsonRefs = (0, _lodash2.default)(parsed.access).pluck('ref').value().join(",");
  var extractor = extractAsText ? '#>>' : '#>';
  var middleQuotedColumnName = parsed.columnName.split('.').join('"."');
  return '"' + middleQuotedColumnName + '"' + extractor + '\'{' + jsonRefs + '}\'';
}

/**
 * Where jsonb reference on left hand side is compared to jsonb value or reference on the right hand side.
 *
 * Converts left and right hand values to PostgreSQL acceptable format and add user chosen
 * operator between left and right hand expressions.
 *
 * ```javascript
 * whereJsonbRefOnLeftJsonbValOrRefOnRight(queryBuilder, "ModelJson.jsonObject:objectField", "<@", { key: 1 })
 * ```
 *
 * ```sql
 * select * from "ModelJson" where ("ModelJson"."jsonObject"#>'{objectField}')::jsonb <@ '{\"key\":\ 1}'::jsonb
 * ```
 *
 * @private
 * @param {QueryBuilderBase} builder
 * @param {FieldExpression} fieldExpression Reference to column / jsonField.
 * @param {string} operator operator to apply.
 * @param {Object|Array|FieldExpression} jsonObjectOrFieldExpression Reference to column / jsonField or json object.
 * @param {string=} queryPrefix string prepended to query e.g. 'not'. Space after string added implicitly.
 * @returns {QueryBuilderBase}
 */
function whereJsonbRefOnLeftJsonbValOrRefOnRight(builder, fieldExpression, operator, jsonObjectOrFieldExpression, queryPrefix) {
  var queryParams = whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(fieldExpression, operator, jsonObjectOrFieldExpression, queryPrefix);
  return builder.whereRaw.apply(builder, queryParams);
}

/**
 * @private
 * @see {@link whereJsonbRefOnLeftJsonbValOrRefOnRight} for documentation.
 */
function orWhereJsonbRefOnLeftJsonbValOrRefOnRight(builder, fieldExpression, operator, jsonObjectOrFieldExpression, queryPrefix) {
  var queryParams = whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(fieldExpression, operator, jsonObjectOrFieldExpression, queryPrefix);
  return builder.orWhereRaw.apply(builder, queryParams);
}

/**
 * @private
 * @see {@link whereJsonbRefOnLeftJsonbValOrRefOnRight} for documentation.
 * @return {Array} Parameters for whereRaw call.
 */
function whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(fieldExpression, operator, jsonObjectOrFieldExpression, queryPrefix) {
  var fieldReference = parseFieldExpression(fieldExpression);

  if (_lodash2.default.isString(jsonObjectOrFieldExpression)) {
    var rightHandReference = parseFieldExpression(jsonObjectOrFieldExpression);
    var refRefQuery = ["(", fieldReference, ")::jsonb", operator, "(", rightHandReference, ")::jsonb"];
    if (queryPrefix) {
      refRefQuery.unshift(queryPrefix);
    }
    return [refRefQuery.join(" ")];
  } else if (_lodash2.default.isObject(jsonObjectOrFieldExpression)) {
    var refValQuery = ["(", fieldReference, ")::jsonb", operator, "?::jsonb"];
    if (queryPrefix) {
      refValQuery.unshift(queryPrefix);
    }
    return [refValQuery.join(" "), (0, _stringify2.default)(jsonObjectOrFieldExpression)];
  }

  throw new Error("Invalid right hand expression.");
}

/**
 * Where field expression on left side and string or an array of strings on right hand side.
 *
 * ```javascript
 * whereJsonFieldRightStringArrayOnLeft(queryBuilder, "ModelJson.jsonObject:a", "?&",  ["1","2"])
 * ```
 *
 * ```sql
 * select * from "ModelJson" where "ModelJson"."jsonObject"#>'{a}' ?& array['1','2']
 * ```
 *
 * @private
 * @param {QueryBuilderBase} builder
 * @param {FieldExpression} fieldExpression
 * @param {string} operator
 * @param {Array.<string>} keys
 * @returns {QueryBuilderBase}
 */
function whereJsonFieldRightStringArrayOnLeft(builder, fieldExpression, operator, keys) {
  return builder.whereRaw(whereJsonFieldRightStringArrayOnLeftQuery(builder, fieldExpression, operator, keys));
}

/**
 * @private
 * @see {@link whereJsonFieldRightStringArrayOnLeft} for documentation.
 */
function orWhereJsonFieldRightStringArrayOnLeft(builder, fieldExpression, operator, keys) {
  return builder.orWhereRaw(whereJsonFieldRightStringArrayOnLeftQuery(builder, fieldExpression, operator, keys));
}

/**
 * @private
 * @see {@link whereJsonFieldRightStringArrayOnLeft} for documentation.
 */
function whereJsonFieldRightStringArrayOnLeftQuery(builder, fieldExpression, operator, keys) {
  var knex = builder._knex;
  var fieldReference = parseFieldExpression(fieldExpression);
  keys = _lodash2.default.isArray(keys) ? keys : [keys];

  var questionMarksArray = _lodash2.default.map(keys, function (key) {
    if (!_lodash2.default.isString(key)) {
      throw new Error("All keys to find must be strings.");
    }
    return "?";
  });

  var rawSqlTemplateString = "array[" + questionMarksArray.join(",") + "]";
  var rightHandExpression = knex.raw(rawSqlTemplateString, keys);

  return fieldReference + ' ' + operator.replace('?', '\\?') + ' ' + rightHandExpression;
}

/**
 * @private
 * @see {@link QueryBuilderBase#whereJsonField} for documentation.
 */
function whereJsonFieldQuery(knex, fieldExpression, operator, value) {
  var fieldReference = parseFieldExpression(fieldExpression, true);
  var normalizedOperator = normalizeOperator(knex, operator);

  // json type comparison takes json type in string format
  var cast = undefined;
  var escapedValue = knex.raw(" ?", [value]);
  if (_lodash2.default.isNumber(value)) {
    cast = "::NUMERIC";
  } else if (_lodash2.default.isBoolean(value)) {
    cast = "::BOOLEAN";
  } else if (_lodash2.default.isString(value)) {
    cast = "::TEXT";
  } else if (_lodash2.default.isNull(value)) {
    cast = "::TEXT";
    escapedValue = 'NULL';
  } else {
    throw new Error("Value must be string, number, boolean or null.");
  }

  return '(' + fieldReference + ')' + cast + ' ' + normalizedOperator + ' ' + escapedValue;
}

/**
 * @private
 * @param knex
 * @param {string} operator
 * @returns {string}
 */
function normalizeOperator(knex, operator) {
  var trimmedLowerCase = operator.trim().toLowerCase();

  switch (trimmedLowerCase) {
    case "is":
    case "is not":
      return trimmedLowerCase;
    default:
      return knex.client.formatter().operator(operator);
  }
}