'use strict';

var _dec, _desc, _value, _class;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get3 = require('babel-runtime/helpers/get');

var _get4 = _interopRequireDefault(_get3);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _RelationExpression = require('./RelationExpression');

var _RelationExpression2 = _interopRequireDefault(_RelationExpression);

var _InsertionOrUpdate = require('./InsertionOrUpdate');

var _InsertionOrUpdate2 = _interopRequireDefault(_InsertionOrUpdate);

var _InsertWithRelated = require('./InsertWithRelated');

var _InsertWithRelated2 = _interopRequireDefault(_InsertWithRelated);

var _QueryBuilderBase2 = require('./QueryBuilderBase');

var _QueryBuilderBase3 = _interopRequireDefault(_QueryBuilderBase2);

var _ValidationError = require('../ValidationError');

var _ValidationError2 = _interopRequireDefault(_ValidationError);

var _EagerFetcher = require('./EagerFetcher');

var _EagerFetcher2 = _interopRequireDefault(_EagerFetcher);

var _dbUtils = require('../utils/dbUtils');

var _decorators = require('../utils/decorators');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Query builder for Models.
 *
 * This class is a wrapper around <a href="http://knexjs.org#Builder">knex QueryBuilder</a>.
 * QueryBuilder has all the methods a knex QueryBuilder has and more. While knex
 * QueryBuilder returns plain javascript objects, QueryBuilder returns Model
 * subclass instances.
 *
 * QueryBuilder is thenable, meaning that it can be used like a promise. You can
 * return query builder from a `.then` method of a promise and it gets chained just like
 * a normal promise would.
 *
 * The query is executed when one of its promise methods `then()`, `catch()`, `map()`,
 * `bind()` or `return()` is called.
 *
 * @constructor
 * @extends QueryBuilderBase
 */
var QueryBuilder = (_dec = (0, _decorators.deprecated)({ removedIn: '0.6.0', useInstead: 'debug()' }), (_class = function (_QueryBuilderBase) {
  (0, _inherits3.default)(QueryBuilder, _QueryBuilderBase);

  function QueryBuilder(modelClass) {
    (0, _classCallCheck3.default)(this, QueryBuilder);

    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(QueryBuilder).call(this, modelClass.knex()));

    _this._modelClass = modelClass;
    _this._calledWriteMethod = null;
    _this._explicitRejectValue = null;
    _this._explicitResolveValue = null;

    _this._hooks = null;
    _this._customImpl = null;

    _this._eagerExpression = null;
    _this._eagerFilters = null;
    _this._allowedEagerExpression = null;
    _this._allowedInsertExpression = null;

    _this.clearHooks();
    _this.clearCustomImpl();
    return _this;
  }

  /**
   * Create QueryBuilder for a Model subclass.
   *
   * @param {Model} modelClass
   *    Model subclass.
   */

  (0, _createClass3.default)(QueryBuilder, [{
    key: 'context',

    /**
     * Sets/gets the query context.
     *
     * Some query builder methods create more than one query. The query context is an object that is
     * shared with all queries started by a query builder. You can set the context like this:
     *
     * ```js
     * Person
     *   .query()
     *   .context({something: 'hello'});
     * ```
     *
     * and access the context like this:
     *
     * ```js
     * var context = builder.context();
     * ```
     *
     * You can set any data to the context object. You can also register QueryBuilder lifecycle methods
     * for _all_ queries that share the context:
     *
     * ```js
     * Person
     *   .query()
     *   .context({
     *     runBefore: function (builder) {},
     *     runAfter: function (builder) {},
     *     onBuild: function (builder) {}
     *   });
     * ```
     *
     * For example the `eager` method causes multiple queries to be executed from a single query builder.
     * If you wanted to make all of them use the same schema you could write this:
     *
     * ```js
     * Person
     *   .query()
     *   .eager('[movies, children.movies])
     *   .context({
     *     onBuild: function (builder) {
     *       builder.withSchema('someSchema');
     *     }
     *   });
     * ```
     *
     * The context is also passed to `$beforeInsert`, `$afterInsert`, `$beforeUpdate` and `$afterUpdate`
     * calls that the query creates.
     *
     * See the methods {@link QueryBuilder#runBefore}, {@link QueryBuilder#onBuild} and
     * {@link QueryBuilder#runAfter} for more information about the hooks.
     *
     * @param {Object=} ctx
     * @returns {QueryBuilder|Object}
     */
    value: function context() {
      var _get2;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // This implementation is here just so that we can document it.
      return (_get2 = (0, _get4.default)((0, _getPrototypeOf2.default)(QueryBuilder.prototype), 'context', this)).call.apply(_get2, [this].concat(args));
    }

    /**
     * Should call this for all other queries a QueryBuilder starts with the "parent" query as parameter.
     *
     * For internal use only.
     *
     * @ignore
     * @param {QueryBuilderBase} query
     */

  }, {
    key: 'childQueryOf',
    value: function childQueryOf(query) {
      if (query) {
        this.internalContext(query.internalContext());

        if (query.has(/debug/)) {
          this.debug();
        }
      }
      return this;
    }

    /**
     * Skips the database query and "fakes" an error result.
     *
     * @param {Error} error
     * @returns {QueryBuilder}
     */

  }, {
    key: 'reject',
    value: function reject(error) {
      this._explicitRejectValue = error;
      return this;
    }

    /**
     * Skips the database query and "fakes" a result.
     *
     * @param {*} value
     * @returns {QueryBuilder}
     */

  }, {
    key: 'resolve',
    value: function resolve(value) {
      this._explicitResolveValue = value;
      return this;
    }

    /**
     * Returns false if this query will never be executed.
     *
     * This may be true in multiple cases:
     *
     * 1. The query is explicitly resolved or rejected using the `resolve` or `reject` methods.
     * 2. The query starts a different query when it is executed.
     *
     * @returns {boolean}
     */

  }, {
    key: 'isExecutable',
    value: function isExecutable() {
      return !this._explicitRejectValue && !this._explicitResolveValue && !this._hooks.executor;
    }

    /**
     * Registers a function to be called before the database query when the builder is executed.
     *
     * Multiple functions can be chained like `then` methods of a promise.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .runBefore(function () {
     *    console.log('hello 1');
     *
     *    return Promise.delay(10).then(function () {
     *      console.log('hello 2');
     *    });
     *  })
     *  .runBefore(function () {
     *    console.log('hello 3');
     *  });
     *
     * query.then();
     * // --> hello 1
     * // --> hello 2
     * // --> hello 3
     * ```
     *
     * @param {function(*, QueryBuilder)} runBefore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'runBefore',
    value: function runBefore(_runBefore) {
      this._hooks.before.push(_runBefore);
      return this;
    }

    /**
     * Just like `runBefore` but pushes the function before any other runBefore functions.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .runBefore(function (result, queryBuilder) {
     *    console.log('hello', result);
     *  })
     *  .runBeforePushFront(function () {
     *    console.log('hello 2');
     *    return 1;
     *  });
     *
     * query.then();
     * // --> hello 2
     * // --> hello 1
     * ```
     *
     * @ignore
     * @param {function(*, QueryBuilder)} runBefore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'runBeforePushFront',
    value: function runBeforePushFront(runBefore) {
      this._hooks.before.unshift(runBefore);
      return this;
    }

    /**
     * Functions registered with this method are called as the last thing before the query is executed.
     *
     * If you need to modify the SQL query at query build time, this is the place to do it. You shouldn't
     * modify the query in any of the `run*` methods.
     *
     * Unlike the run* methods these must be synchronous. Also you should not register any run* methods
     * from these. You should _only_ call the query building methods of the builder provided as a parameter.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .onBuild(function (builder) {
     *    builder.where('id', 1);
     *  })
     *  .onBuild(function () {
     *    builder.orWhere('id', 2);
     *  });
     * ```
     *
     * @param {function(QueryBuilder)} onBuild
     * @returns {QueryBuilder}
     */

  }, {
    key: 'onBuild',
    value: function onBuild(_onBuild) {
      this._hooks.onBuild.push(_onBuild);
      return this;
    }

    /**
     * Sets a custom query executor.
     *
     * Setting this will cause the query builder to not be executed. Instead the fully built
     * query builder is passed to the function registered using this method and the function
     * should return some other query to execute.
     *
     * @ignore
     * @param {function(QueryBuilder)} executor
     * @returns {QueryBuilder}
     */

  }, {
    key: 'setQueryExecutor',
    value: function setQueryExecutor(executor) {
      if (this._hooks.executor) {
        throw Error('overwriting an executor. you should not do this.');
      }

      this._hooks.executor = executor;
      return this;
    }

    /**
     * Registers a function to be called after the database rows are converted to Model instances.
     *
     * Multiple functions can be chained like `then` methods of a promise.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .runAfterModelCreate(function (models, queryBuilder) {
     *    models.push(Person.fromJson({firstName: 'Jennifer'}));
     *  });
     *
     * query.then(function (models) {
     *   var jennifer = models[models.length - 1];
     * });
     * ```
     *
     * @ignore
     * @param {function(Model|Array.<Model>, QueryBuilder)} runAfterModelCreate
     * @returns {QueryBuilder}
     */

  }, {
    key: 'runAfterModelCreate',
    value: function runAfterModelCreate(_runAfterModelCreate) {
      this._hooks.afterModelCreate.push(_runAfterModelCreate);
      return this;
    }

    /**
     * Just like `runAfterModelCreate` but pushes the function before any other runAfterModelCreate functions.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .runAfterModelCreate(function (models) {
     *    console.log('hello 1');
     *    return models;
     *  })
     *  .runAfterModelCreatePushFront(function (models, queryBuilder) {
     *    console.log('hello 2');
     *    return models;
     *  });
     *
     * query.then();
     * // --> hello 2
     * // --> hello 1
     * ```
     *
     * @ignore
     * @param {function(Model|Array.<Model>, QueryBuilder)} runAfterModelCreate
     * @returns {QueryBuilder}
     */

  }, {
    key: 'runAfterModelCreatePushFront',
    value: function runAfterModelCreatePushFront(runAfterModelCreate) {
      this._hooks.afterModelCreate.unshift(runAfterModelCreate);
      return this;
    }

    /**
     * Registers a function to be called when the builder is executed.
     *
     * These functions are executed as the last thing before any promise handlers
     * registered using the `then` method. Multiple functions can be chained like
     * `then` methods of a promise.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .runAfter(function (models, queryBuilder) {
     *    return models;
     *  })
     *  .runAfter(function (models, queryBuilder) {
     *    models.push(Person.fromJson({firstName: 'Jennifer'}));
     *  });
     *
     * query.then(function (models) {
     *   var jennifer = models[models.length - 1];
     * });
     * ```
     *
     * @param {function(Model|Array.<Model>, QueryBuilder)} runAfter
     * @returns {QueryBuilder}
     */

  }, {
    key: 'runAfter',
    value: function runAfter(_runAfter) {
      this._hooks.after.push(_runAfter);
      return this;
    }

    /**
     * Just like `runAfter` but pushes the function before any other runAfter functions.
     *
     * ```js
     * var query = Person.query();
     *
     * query
     *  .runAfter(function (models) {
     *    console.log('hello 1');
     *    return models;
     *  })
     *  .runAfterPushFront(function (models, queryBuilder) {
     *    console.log('hello 2');
     *    return models;
     *  });
     *
     * query.then();
     * // --> hello 2
     * // --> hello 1
     * ```
     *
     * @param {function(Model|Array.<Model>, QueryBuilder)} runAfter
     * @returns {QueryBuilder}
     */

  }, {
    key: 'runAfterPushFront',
    value: function runAfterPushFront(runAfter) {
      this._hooks.after.unshift(runAfter);
      return this;
    }

    /**
     * Registers a custom find implementation.
     *
     * The find implementation is executed if none of the `insert`, `update`, `patch`, `relate`
     * etc. functions are called.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'findImpl',
    value: function findImpl(_findImpl) {
      this._customImpl.find = _findImpl || null;
      return this;
    }

    /**
     * Registers a custom insert implementation.
     *
     * The registered method is called when `insert()` is called for a query builder.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'insertImpl',
    value: function insertImpl(_insertImpl) {
      this._customImpl.insert = _insertImpl || null;
      return this;
    }

    /**
     * Registers a custom update implementation.
     *
     * The registered method is called when `update()` is called for a query builder.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'updateImpl',
    value: function updateImpl(_updateImpl) {
      this._customImpl.update = _updateImpl || null;
      return this;
    }

    /**
     * Registers a custom patch implementation.
     *
     * The registered method is called when `patch()` is called for a query builder.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'patchImpl',
    value: function patchImpl(_patchImpl) {
      this._customImpl.patch = _patchImpl || null;
      return this;
    }

    /**
     * Registers a custom delete implementation.
     *
     * The registered method is called when `delete()` is called for a query builder.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'deleteImpl',
    value: function deleteImpl(_deleteImpl) {
      this._customImpl.delete = _deleteImpl || null;
      return this;
    }

    /**
     * Registers a custom relate implementation.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'relateImpl',
    value: function relateImpl(_relateImpl) {
      this._customImpl.relate = _relateImpl || null;
      return this;
    }

    /**
     * Registers a custom unrelate implementation.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'unrelateImpl',
    value: function unrelateImpl(_unrelateImpl) {
      this._customImpl.unrelate = _unrelateImpl || null;
      return this;
    }

    /**
     * Fetch relations eagerly for the result rows.
     *
     * Example:
     *
     * ```js
     * // Fetch `children` relation for each result Person and `pets` and `movies`
     * // relations for all the children.
     * Person
     *   .query()
     *   .eager('children.[pets, movies]')
     *   .then(function (persons) {
     *     console.log(persons[0].children[0].pets[0].name);
     *     console.log(persons[0].children[0].movies[0].id);
     *   });
     * ```
     *
     * Relations can be filtered by giving named filter functions as arguments
     * to the relations:
     *
     * ```js
     * Person
     *   .query()
     *   .eager('children(orderByAge).[pets(onlyDogs, orderByName), movies]', {
     *     orderByAge: function (builder) {
     *       builder.orderBy('age')
     *     },
     *     orderByName: function (builder) {
     *       builder.orderBy('name');
     *     },
     *     onlyDogs: function (builder) {
     *       builder.where('species', 'dog')
     *     }
     *   })
     *   .then(function (persons) {
     *     console.log(persons[0].children[0].pets[0].name);
     *     console.log(persons[0].children[0].movies[0].id);
     *   });
     * ```
     *
     * The eager queries are optimized to avoid the N + 1 query problem. Consider this query:
     *
     * ```js
     * Person
     *   .query()
     *   .where('id', 1)
     *   .eager('children.children')
     *   .then(function (persons) {
     *     console.log(persons[0].children.length); // --> 10
     *     console.log(persons[0].children[9].children.length); // --> 10
     *   });
     * ```
     *
     * The person has 10 children and they all have 10 children. The query above will
     * return 100 database rows but will generate only three database queries.
     *
     * See {@link RelationExpression} for more examples and documentation.
     *
     * @param {string|RelationExpression} exp
     * @param {Object.<string, function(QueryBuilder)>=} filters
     * @returns {QueryBuilder}
     */

  }, {
    key: 'eager',
    value: function eager(exp, filters) {
      this._eagerExpression = exp || null;
      this._eagerFilters = filters || null;

      if (_lodash2.default.isString(this._eagerExpression)) {
        this._eagerExpression = _RelationExpression2.default.parse(this._eagerExpression);
      }

      checkEager(this);
      return this;
    }

    /**
     * Sets the allowed eager expression.
     *
     * Any subset of the allowed expression is accepted by `eager` method. For example setting
     * the allowed expression to `a.b.c` expressions `a`, `a.b` and `a.b.c` are accepted by `eager`
     * method. Setting any other expression will reject the query and cause the promise error handlers
     * to be called.
     *
     * This method is useful when the eager expression comes from an untrusted source like query
     * parameters of a http request.
     *
     * ```js
     * Person
     *   .query()
     *   .allowEager('[children.pets, movies]')
     *   .eager(req.query.eager)
     *   .then(function () {
     *
     *   });
     * ```
     *
     * @param {string|RelationExpression} exp
     * @returns {QueryBuilder}
     */

  }, {
    key: 'allowEager',
    value: function allowEager(exp) {
      this._allowedEagerExpression = exp || null;

      if (_lodash2.default.isString(this._allowedEagerExpression)) {
        this._allowedEagerExpression = _RelationExpression2.default.parse(this._allowedEagerExpression);
      }

      checkEager(this);
      return this;
    }

    /**
     * Sets the allowed tree of relations to insert using `insertWithRelated` method.
     *
     * If the model tree given to the `insertWithRelated` method isn't a subtree of the
     * given expression, the query is rejected.
     *
     * ```js
     * Person
     *   .query()
     *   .allowInsert('[children.pets, movies]')
     *   .insertWithRelated({
     *     firstName: 'Sylvester',
     *     children: [{
     *       firstName: 'Sage',
     *       pets: [{
     *         name: 'Fluffy'
     *         species: 'dog'
     *       }, {
     *         name: 'Scrappy',
     *         species: 'dog'
     *       }]
     *     }]
     *   })
     *   .then(function () {
     *
     *   });
     * ```
     *
     * See methods `QueryBuilder.eager`, `QueryBuilder.allowEager` and class {@link RelationExpression} for
     * more information on relation expressions.
     *
     * @param {string|RelationExpression} exp
     * @returns {QueryBuilder}
     */

  }, {
    key: 'allowInsert',
    value: function allowInsert(exp) {
      this._allowedInsertExpression = exp || null;

      if (_lodash2.default.isString(this._allowedInsertExpression)) {
        this._allowedInsertExpression = _RelationExpression2.default.parse(this._allowedInsertExpression);
      }

      return this;
    }

    /**
     * Gets the Model subclass this builder is bound to.
     *
     * @returns {Model}
     */

  }, {
    key: 'modelClass',
    value: function modelClass() {
      return this._modelClass;
    }

    /**
     * Returns true if none of the methods `insert`, `.update`, `patch`, `delete`, `relate` or `unrelate` has been called.
     *
     * @ignore
     * @returns {boolean}
     */

  }, {
    key: 'isFindQuery',
    value: function isFindQuery() {
      return !this._calledWriteMethod && !this.has(/insert|update|delete/);
    }

    /**
     * Returns the SQL string.
     *
     * @returns {string}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.build().toString();
    }

    /**
     * Returns the SQL string.
     *
     * @returns {string}
     */

  }, {
    key: 'toSql',
    value: function toSql() {
      return this.toString();
    }

    /**
     * Logs the SQL string.
     *
     * Handy for debugging:
     *
     * ```js
     * Person
     *   .query()
     *   .where('firstName', 'Jennifer')
     *   .where('age', 100)
     *   .dumpSql()
     *   .then(function () {
     *     ...
     *   });
     * ```
     *
     * @param {function(string)=} logger
     * @returns {QueryBuilder}
     */

  }, {
    key: 'dumpSql',
    value: function dumpSql(logger) {
      (logger || console.log)(this.toString());
      return this;
    }

    /**
     * Create a clone of this builder.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clone',
    value: function clone() {
      var builder = new this.constructor(this._modelClass);
      // This is a QueryBuilderBase method.
      this.cloneInto(builder);

      builder._calledWriteMethod = this._calledWriteMethod;
      builder._explicitRejectValue = this._explicitRejectValue;
      builder._explicitResolveValue = this._explicitResolveValue;

      _lodash2.default.forEach(this._hooks, function (funcs, key) {
        builder._hooks[key] = _lodash2.default.isArray(funcs) ? funcs.slice() : funcs;
      });

      _lodash2.default.forEach(this._customImpl, function (impl, key) {
        builder._customImpl[key] = impl;
      });

      builder._eagerExpression = this._eagerExpression;
      builder._eagerFilters = this._eagerFilters;
      builder._allowedEagerExpression = this._allowedEagerExpression;
      builder._allowedInsertExpression = this._allowedInsertExpression;

      return builder;
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clearCustomImpl',
    value: function clearCustomImpl() {
      this._customImpl = {
        find: function find() {},
        relate: function relate() {},
        unrelate: function unrelate() {},
        insert: function insert(_insert, builder) {
          builder.onBuild(function (builder) {
            builder.$$insert(_insert);
          });
        },
        update: function update(_update, builder) {
          builder.onBuild(function (builder) {
            builder.$$update(_update);
          });
        },
        patch: function patch(_patch, builder) {
          builder.onBuild(function (builder) {
            builder.$$update(_patch);
          });
        },
        delete: function _delete(builder) {
          builder.onBuild(function (builder) {
            builder.$$delete();
          });
        }
      };

      return this;
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clearHooks',
    value: function clearHooks() {
      this._hooks = {
        before: [],
        onBuild: [],
        executor: null,
        afterModelCreate: [],
        after: []
      };

      return this;
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clearEager',
    value: function clearEager() {
      this._eagerExpression = null;
      this._eagerFilters = null;
      return this;
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clearReject',
    value: function clearReject() {
      this._explicitRejectValue = null;
      return this;
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clearResolve',
    value: function clearResolve() {
      this._explicitResolveValue = null;
      return this;
    }

    /**
     * Removes query builder method calls.
     *
     * @param {RegExp=} regex
     *    Optional patter to that must match the method names to remove.
     *
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: 'clear',
    value: function clear(regex) {
      (0, _get4.default)((0, _getPrototypeOf2.default)(QueryBuilder.prototype), 'clear', this).call(this, regex);

      if (regex) {
        // Clear the write method call also if it doesn't pass the filter.
        if (regex.test(this._calledWriteMethod)) {
          this._calledWriteMethod = null;
        }
      } else {
        this._calledWriteMethod = null;
      }

      return this;
    }

    /**
     * @ignore
     * @param {RegExp} methodNameRegex
     * @returns {boolean}
     */

  }, {
    key: 'has',
    value: function has(methodNameRegex) {
      return (0, _get4.default)((0, _getPrototypeOf2.default)(QueryBuilder.prototype), 'has', this).call(this, methodNameRegex) || methodNameRegex.test(this._calledWriteMethod);
    }

    /**
     * Executes the query and returns a Promise.
     *
     * @param {function=} successHandler
     * @param {function=} errorHandler
     * @returns {Promise}
     */

  }, {
    key: 'then',
    value: function then() /*successHandler, errorHandler*/{
      var promise = this._execute();
      return promise.then.apply(promise, arguments);
    }

    /**
     * Executes the query and calls `.map(mapper)` for the returned promise.
     *
     * @param {function} mapper
     * @returns {Promise}
     */

  }, {
    key: 'map',
    value: function map() /*mapper*/{
      var promise = this._execute();
      return promise.map.apply(promise, arguments);
    }

    /**
     * Executes the query and calls `.catch(errorHandler)` for the returned promise.
     *
     * @param {function} errorHandler
     * @returns {Promise}
     */

  }, {
    key: 'catch',
    value: function _catch() /*errorHandler*/{
      var promise = this._execute();
      return promise.catch.apply(promise, arguments);
    }

    /**
     * Executes the query and calls `.return(returnValue)` for the returned promise.
     *
     * @param {*} returnValue
     * @returns {Promise}
     */

  }, {
    key: 'return',
    value: function _return() /*returnValue*/{
      var promise = this._execute();
      return promise.return.apply(promise, arguments);
    }

    /**
     * Executes the query and calls `.bind(context)` for the returned promise.
     *
     * @param {*} context
     * @returns {Promise}
     */

  }, {
    key: 'bind',
    value: function bind() /*context*/{
      var promise = this._execute();
      return promise.bind.apply(promise, arguments);
    }

    /**
     * Executes the query and calls `.asCallback(callback)` for the returned promise.
     *
     * @param {function} callback
     * @returns {Promise}
     */

  }, {
    key: 'asCallback',
    value: function asCallback() /*callback*/{
      var promise = this._execute();
      return promise.asCallback.apply(promise, arguments);
    }

    /**
     * Executes the query and calls `.nodeify(callback)` for the returned promise.
     *
     * @param {function} callback
     * @returns {Promise}
     */

  }, {
    key: 'nodeify',
    value: function nodeify() /*callback*/{
      var promise = this._execute();
      return promise.nodeify.apply(promise, arguments);
    }

    /**
     * Returns the amount of rows the current query would produce without `limit` and `offset` applied.
     *
     * Note that this executes a query (not the one we are building) and returns a Promise. Use it
     * like this:
     *
     * ```js
     * var query = Person
     *   .query()
     *   .where('age', '>', 20);
     *
     * Promise.all([
     *   query.resultSize(),
     *   query.offset(100).limit(50)
     * ]).spread(function (total, models) {
     *   ...
     * });
     * ```
     *
     * @returns {Promise}
     */

  }, {
    key: 'resultSize',
    value: function resultSize() {
      var knex = this._modelClass.knex();

      // orderBy is useless here and it can make things a lot slower (at least with postgresql 9.3).
      // Remove it from the count query. We also remove the offset and limit
      var query = this.clone().clear(/orderBy|offset|limit/).build();
      var rawQuery = knex.raw(query).wrap('(', ') as temp');
      var countQuery = knex.count('* as count').from(rawQuery);

      return countQuery.then(function (result) {
        return result[0] ? result[0].count : 0;
      });
    }

    /**
     * Only returns the given page of results.
     *
     * ```js
     * Person
     *   .query()
     *   .where('age', '>', 20)
     *   .page(5, 100)
     *   .then(function (result) {
     *     console.log(result.results.length); // --> 100
     *     console.log(result.total); // --> 3341
     *   });
     * ```
     *
     * @param {number} page
     *    The index of the page to return.
     *
     * @param {number} pageSize
     *    The page size.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'page',
    value: function page(_page, pageSize) {
      return this.range(_page * pageSize, (_page + 1) * pageSize - 1);
    }

    /**
     * Only returns the given range of results.
     *
     * ```js
     * Person
     *   .query()
     *   .where('age', '>', 20)
     *   .range(0, 100)
     *   .then(function (result) {
     *     console.log(result.results.length); // --> 101
     *     console.log(result.total); // --> 3341
     *   });
     * ```
     *
     * @param {number} start
     *    The index of the first result (inclusive).
     *
     * @param {number} end
     *    The index of the last result (inclusive).
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'range',
    value: function range(start, end) {
      var self = this;
      var resultSizePromise = undefined;

      return this.limit(end - start + 1).offset(start).runBefore(function () {
        // Don't return the promise so that it is executed
        // in parallel with the actual query.
        resultSizePromise = self.resultSize();
      }).runAfter(function (results) {
        // Now that the actual query is finished, wait until the
        // result size has been calculated.
        return _bluebird2.default.all([results, resultSizePromise]);
      }).runAfter(function (arr) {
        return {
          results: arr[0],
          total: _lodash2.default.parseInt(arr[1])
        };
      });
    }
  }, {
    key: 'build',

    /**
     * Builds the query into a knex query builder.
     *
     * @ignore
     * @returns {knex.QueryBuilder}
     *    The built knex query builder.
     */
    value: function build() {
      var builder = this.clone();

      if (builder.isFindQuery()) {
        // If no write methods have been called at this point this query is a
        // find query and we need to call the custom find implementation.
        builder._customImpl.find.call(builder, builder);
      }

      // We need to build the builder even if the _hooks.executor function
      // has been defined so that the onBuild hooks get called.
      var knexBuilder = _build(builder);

      if (_lodash2.default.isFunction(builder._hooks.executor)) {
        // If the query executor is set, we build the builder that it returns.
        return builder._hooks.executor.call(builder, builder).build();
      } else {
        return knexBuilder;
      }
    }

    /**
     * @private
     * @returns {Promise}
     */

  }, {
    key: '_execute',
    value: function _execute() {
      // Take a clone so that we don't modify this instance during execution.
      // The hooks and onBuild callbacks usually modify the query and we want
      // this builder to be re-executable.
      var builder = this.clone();
      var context = builder.context() || {};
      var promise = _bluebird2.default.resolve();

      if (builder.isFindQuery()) {
        // If no write methods have been called at this point this query is a
        // find query and we need to call the custom find implementation.
        builder._customImpl.find.call(builder, builder);
      }

      if (_lodash2.default.isFunction(context.runBefore)) {
        promise = promise.then(function (result) {
          return context.runBefore.call(builder, result, builder);
        });
      }

      _lodash2.default.forEach(builder._hooks.before, function (func) {
        promise = promise.then(function (result) {
          return func.call(builder, result, builder);
        });
      });

      // Resolve all before hooks before building and executing the query
      // and the rest of the hooks.
      return promise.then(function () {
        // We need to build the builder even if the _explicit(Resolve|Reject)Value or _hooks.executor
        // has been defined so that the onBuild hooks get called.
        var knexBuilder = _build(builder);
        var promise = undefined;

        if (builder._explicitResolveValue) {
          promise = _bluebird2.default.resolve(builder._explicitResolveValue);
        } else if (builder._explicitRejectValue) {
          promise = _bluebird2.default.reject(builder._explicitRejectValue);
        } else if (_lodash2.default.isFunction(builder._hooks.executor)) {
          promise = builder._hooks.executor.call(builder, builder);
        } else {
          promise = knexBuilder.then(function (result) {
            return createModels(builder, result);
          });
        }

        _lodash2.default.forEach(builder._hooks.afterModelCreate, function (func) {
          promise = promise.then(function (result) {
            return func.call(builder, result, builder);
          });
        });

        if (builder._eagerExpression) {
          promise = promise.then(function (models) {
            return eagerFetch(builder, models);
          });
        }

        if (_lodash2.default.isFunction(context.runAfter)) {
          promise = promise.then(function (result) {
            return context.runAfter.call(builder, result, builder);
          });
        }

        _lodash2.default.forEach(builder._hooks.after, function (func) {
          promise = promise.then(function (result) {
            return func.call(builder, result, builder);
          });
        });

        return promise;
      });
    }

    /**
     * If the result is an array, plucks a property from each object.
     *
     * ```js
     * Person
     *   .query()
     *   .where('age', '>', 20)
     *   .pluck('firstName')
     *   .then(function (firstNames) {
     *     console.log(typeof firstNames[0]); // --> string
     *   });
     * ```
     *
     * @param {string} propertyName
     *    The name of the property to pluck.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'pluck',
    value: function pluck(propertyName) {
      return this.runAfter(function (result) {
        if (_lodash2.default.isArray(result)) {
          return _lodash2.default.pluck(result, propertyName);
        } else {
          return result;
        }
      });
    }

    /**
     * If the result is an array, selects the first item.
     *
     * ```js
     * Person
     *   .query()
     *   .first()
     *   .then(function (firstPerson) {
     *     console.log(person.age);
     *   });
     * ```
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'first',
    value: function first() {
      return this.runAfter(function (result) {
        if (_lodash2.default.isArray(result)) {
          return result[0];
        } else {
          return result;
        }
      });
    }

    /**
     * Traverses through all models in the result, including the eagerly loaded relations.
     *
     * The optional first parameter can be a constructor. If given, the traverser
     * function is only called for the models of that class.
     *
     * ```js
     * Person
     *   .query()
     *   .eager('pets')
     *   .traverse(function (model, parentModel, relationName) {
     *     delete model.id;
     *   })
     *   .then(function (persons) {
     *     console.log(persons[0].id); // --> undefined
     *     console.log(persons[0].pets[0].id); // --> undefined
     *   });
     * ```
     *
     * ```js
     * Person
     *   .query()
     *   .eager('pets')
     *   .traverse(Animal, function (animal, parentModel, relationName) {
     *     delete animal.id;
     *   })
     *   .then(function (persons) {
     *     console.log(persons[0].id); // --> 1
     *     console.log(persons[0].pets[0].id); // --> undefined
     *   });
     * ```
     *
     * @param {Model|function} modelClass
     *    The optional model class filter. If given, the traverser function is only
     *    called for models of this class.
     *
     * @param {function(Model, Model, string)} traverser
     *    The traverser function that is called for each model. The first argument
     *    is the model itself. If the model is in a relation of some other model
     *    the second argument is the parent model and the third argument is the
     *    name of the relation.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'traverse',
    value: function traverse(modelClass, traverser) {
      var self = this;

      if (_lodash2.default.isUndefined(traverser)) {
        traverser = modelClass;
        modelClass = null;
      }

      return this.runAfter(function (result) {
        self._modelClass.traverse(modelClass, result, traverser);
        return result;
      });
    }

    /**
     * Pick properties from result models.
     *
     * There are two ways to call this methods:
     *
     * ```js
     * Person
     *   .query()
     *   .eager('pets').
     *   .pick(['id', 'name']);
     * ```
     *
     * and
     *
     * ```js
     * Person
     *   .query()
     *   .eager('pets')
     *   .pick(Person, ['id', 'firstName'])
     *   .pick(Animal, ['id', 'name']);
     * ```
     *
     * The first one goes through all models (including relations) and discards all
     * properties by `id` and `name`. The second one also traverses the whole model
     * tree and discards all but `id` and `firstName` properties of all `Person`
     * instances and `id` and `name` properties of all `Animal` instances.
     *
     * @param {Model=} modelClass
     * @param {Array.<string>} properties
     * @returns {QueryBuilder}
     */

  }, {
    key: 'pick',
    value: function pick(modelClass, properties) {
      if (_lodash2.default.isUndefined(properties)) {
        properties = modelClass;
        modelClass = null;
      }

      properties = _lodash2.default.reduce(properties, function (obj, prop) {
        obj[prop] = true;
        return obj;
      }, {});

      return this.traverse(modelClass, function (model) {
        model.$pick(properties);
      });
    }

    /**
     * Omit properties of result models.
     *
     * There are two ways to call this methods:
     *
     * ```js
     * Person
     *   .query()
     *   .eager('pets').
     *   .omit(['parentId', 'ownerId']);
     * ```
     *
     * and
     *
     * ```js
     * Person
     *   .query()
     *   .eager('pets')
     *   .omit(Person, ['parentId', 'age'])
     *   .omit(Animal, ['ownerId', 'species']);
     * ```
     *
     * The first one goes through all models (including relations) and omits the properties
     * `parentId` and `ownerId`. The second one also traverses the whole model tree and
     * omits the properties `parentId` and `age` from all `Person` instances and `ownerId`
     * and `species` properties of all `Animal` instances.
     *
     * @param {Model=} modelClass
     * @param {Array.<string>} properties
     * @returns {QueryBuilder}
     */

  }, {
    key: 'omit',
    value: function omit(modelClass, properties) {
      if (_lodash2.default.isUndefined(properties)) {
        properties = modelClass;
        modelClass = null;
      }

      // Turn the properties into a hash for performance.
      properties = _lodash2.default.reduce(properties, function (obj, prop) {
        obj[prop] = true;
        return obj;
      }, {});

      return this.traverse(modelClass, function (model) {
        model.$omit(properties);
      });
    }

    /**
     * Shortcut for finding a model by id.
     *
     * ```js
     * Person.query().findById(1);
     * ```
     *
     * Composite key:
     *
     * ```js
     * Person.query().findById([1, '10']);
     * ```
     *
     * @param {*|Array.<*>} id
     * @returns {QueryBuilder}
     */

  }, {
    key: 'findById',
    value: function findById(id) {
      return this.whereComposite(this._modelClass.getFullIdColumn(), id).first();
    }

    /**
     * Creates an insert query.
     *
     * The inserted objects are validated against the model's `jsonSchema`. If validation fails
     * the Promise is rejected with a `ValidationError`.
     *
     * NOTE: The return value of the insert query _only_ contains the properties given to the insert
     * method plus the identifier. This is because we don't make an additional fetch query after
     * the insert. Using postgres you can chain `.returning('*')` to the query to get all properties.
     * On other databases you can use the `insertAndFetch` method.
     *
     * Examples:
     *
     * ```js
     * Person
     *   .query()
     *   .insert({firstName: 'Jennifer', lastName: 'Lawrence'})
     *   .then(function (jennifer) {
     *     console.log(jennifer.id);
     *   });
     * ```
     *
     * Batch insert (Only works on Postgres):
     *
     * ```js
     * someMovie
     *   .$relatedQuery('actors')
     *   .insert([
     *     {firstName: 'Jennifer', lastName: 'Lawrence'},
     *     {firstName: 'Bradley', lastName: 'Cooper'}
     *   ])
     *   .then(function (actors) {
     *     console.log(actors[0].firstName);
     *     console.log(actors[1].firstName);
     *   });
     * ```
     *
     * You can also give raw expressions and subqueries as values like this:
     *
     * ```js
     * Person
     *   .query()
     *   .insert({
     *     age: Person.query().avg('age'),
     *     firstName: Person.raw("'Jenni' || 'fer'")
     *   });
     * ```
     *
     * The batch insert only works on Postgres because Postgres is the only database engine
     * that returns the identifiers of _all_ inserted rows. knex supports batch inserts on
     * other databases also, but you only get the id of the first (or last) inserted object
     * as a result. If you need batch insert on other databases you can use knex directly
     * through `YourModel.knexQuery()`.
     *
     * @param {Object|Model|Array.<Object>|Array.<Model>} modelsOrObjects
     *    Objects to insert.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'insert',
    value: function insert(modelsOrObjects) {
      var ModelClass = this._modelClass;

      var insertion = new _InsertionOrUpdate2.default({
        ModelClass: ModelClass,
        modelsOrObjects: modelsOrObjects
      });

      this.$$callWriteMethodImpl('insert', [insertion, this]);

      this.runBefore(function (result, builder) {
        if (insertion.models().length > 1 && !(0, _dbUtils.isPostgres)(ModelClass.knex())) {
          throw new Error('batch insert only works with Postgresql');
        } else {
          return _bluebird2.default.map(insertion.models(), function (model) {
            return model.$beforeInsert(builder.context());
          });
        }
      });

      this.onBuild(function (builder) {
        if (!builder.has(/returning/)) {
          // If the user hasn't specified a `returning` clause, we make sure
          // that at least the identifier is returned.
          builder.returning(ModelClass.idColumn);
        }
      });

      this.runAfterModelCreatePushFront(function (ret) {
        if (!_lodash2.default.isArray(ret) || _lodash2.default.isEmpty(ret)) {
          // Early exit if there is nothing to do.
          return insertion.models();
        }

        // If the user specified a `returning` clause the result may already bean array of objects.
        if (_lodash2.default.all(ret, _lodash2.default.isObject)) {
          _lodash2.default.forEach(insertion.models(), function (model, index) {
            model.$set(ret[index]);
          });
        } else {
          // If the return value is not an array of objects, we assume it is an array of identifiers.
          _lodash2.default.forEach(insertion.models(), function (model, idx) {
            // Don't set the id if the model already has one. MySQL and Sqlite don't return the correct
            // primary key value if the id is not generated in db, but given explicitly.
            if (!model.$id()) {
              model.$id(ret[idx]);
            }
          });
        }

        return insertion.models();
      });

      this.runAfterModelCreate(function (models, builder) {
        return _bluebird2.default.map(models, function (model) {
          return model.$afterInsert(builder.context());
        }).then(function () {
          if (insertion.isArray()) {
            return models;
          } else {
            return models[0] || null;
          }
        });
      });

      return this;
    }

    /**
     * Just like `insert` but also fetches the model afterwards.
     *
     * Note that on postgresql you can just chain `.returning('*')` to the normal insert method
     * to get the same result without an additional query.
     *
     * @param {Object|Model|Array.<Object>|Array.<Model>} modelsOrObjects
     *    Objects to insert.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'insertAndFetch',
    value: function insertAndFetch(modelsOrObjects) {
      var ModelClass = this._modelClass;

      return this.insert(modelsOrObjects).runAfterModelCreate(function (insertedModels, builder) {
        var insertedModelArray = _lodash2.default.isArray(insertedModels) ? insertedModels : [insertedModels];

        return ModelClass.query().childQueryOf(builder).whereInComposite(ModelClass.getFullIdColumn(), _lodash2.default.map(insertedModelArray, function (model) {
          return model.$id();
        })).then(function (fetchedModels) {
          fetchedModels = _lodash2.default.indexBy(fetchedModels, function (model) {
            return model.$id();
          });

          // Instead of returning the freshly fetched models, update the input
          // models with the fresh values.
          _lodash2.default.forEach(insertedModelArray, function (insertedModel) {
            insertedModel.$set(fetchedModels[insertedModel.$id()]);
          });

          return insertedModels;
        });
      });
    }

    /**
     * Insert models with relations.
     *
     * You can insert any asyclic graph of models like this:
     *
     * ```js
     * Person
     *   .query()
     *   .insertWithRelated({
     *     firstName: 'Sylvester',
     *     lastName: 'Stallone',
     *
     *     children: [{
     *       firstName: 'Sage',
     *       lastName: 'Stallone',
     *
     *       pets: [{
     *         name: 'Fluffy',
     *         species: 'dog'
     *       }]
     *     }]
     *   });
     * ```
     *
     * The query above will insert 'Sylvester', 'Sage' and 'Fluffy' into db and create
     * relationships between them as defined in the `relationMappings` of the models.
     *
     * If you need to refer to the same model in multiple places you can use the
     * special properties `#id` and `#ref` like this:
     *
     * ```js
     * Person
     *   .query()
     *   .insertWithRelated([{
     *     firstName: 'Jennifer',
     *     lastName: 'Lawrence',
     *
     *     movies: [{
     *       "#id": 'Silver Linings Playbook'
     *       name: 'Silver Linings Playbook',
     *       duration: 122
     *     }]
     *   }, {
     *     firstName: 'Bradley',
     *     lastName: 'Cooper',
     *
     *     movies: [{
     *       "#ref": 'Silver Linings Playbook'
     *     }]
     *   }]);
     * ```
     *
     * The query above will insert only one movie (the 'Silver Linings Playbook') but
     * both 'Jennifer' and 'Bradley' will have the movie related to them through the
     * many-to-many relation `movies`.
     *
     * You can refer to the properties of other models in the graph using expressions
     * of format `#ref{<id>.<property>}` for example:
     *
     * ```js
     * Person
     *   .query()
     *   .insertWithRelated([{
     *     "#id": 'jenniLaw',
     *     firstName: 'Jennifer',
     *     lastName: 'Lawrence',
     *
     *     pets: [{
     *       name: "I am the dog of #ref{jenniLaw.firstName} #ref{jenniLaw.lastName}",
     *       species: 'dog'
     *     }]
     *   }]);
     * ```
     *
     * The query above will insert a pet named `I am the dog of Jennifer Lawrence` for Jennifer.
     *
     * See the `allowInsert` method if you need to limit which relations can be inserted using
     * this method to avoid security issues.
     *
     * By the way, if you are using Postgres the inserts are done in batches for
     * maximum performance.
     *
     * @param {Object|Model|Array.<Object>|Array.<Model>} modelsOrObjects
     *    Objects to insert.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'insertWithRelated',
    value: function insertWithRelated(modelsOrObjects) {
      var ModelClass = this._modelClass;
      var batchSize = (0, _dbUtils.isPostgres)(ModelClass.knex()) ? 100 : 1;

      var insertion = new _InsertionOrUpdate2.default({
        ModelClass: ModelClass,
        modelsOrObjects: modelsOrObjects,
        // We need to skip validation at this point because the models may contain
        // references and special properties. We validate the models upon insertion.
        modelOptions: { skipValidation: true }
      });

      this.$$callWriteMethodImpl('insert', [insertion, this]);

      // We resolve this query here and will not execute it. This is because the root
      // value may depend on other models in the graph and cannot be inserted first.
      this.resolve([]);

      this.runAfterModelCreatePushFront(function (result, builder) {
        var inserter = new _InsertWithRelated2.default({
          modelClass: ModelClass,
          models: insertion.models(),
          allowedRelations: builder._allowedInsertExpression || null
        });

        return inserter.execute(function (tableInsertion) {
          var insertQuery = tableInsertion.modelClass.query().childQueryOf(builder);

          // We skipped the validation above. We need to validate here since at this point
          // the models should no longer contain any special properties.
          _lodash2.default.forEach(tableInsertion.models, function (model) {
            model.$validate();
          });

          var inputs = _lodash2.default.filter(tableInsertion.models, function (model, idx) {
            return tableInsertion.isInputModel[idx];
          });

          var others = _lodash2.default.filter(tableInsertion.models, function (model, idx) {
            return !tableInsertion.isInputModel[idx];
          });

          return _bluebird2.default.all(_lodash2.default.flatten([batchInsert(inputs, insertQuery.clone().copyFrom(builder, /returning/), batchSize), batchInsert(others, insertQuery.clone(), batchSize)]));
        });
      });

      this.runAfterModelCreate(function (models) {
        if (insertion.isArray()) {
          return models;
        } else {
          return _lodash2.default.first(models) || null;
        }
      });
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: '$$insert',
    value: function $$insert(insertion) {
      var input = insertion;

      if (insertion instanceof _InsertionOrUpdate2.default) {
        input = insertion.toKnexInput();
      } else if (_lodash2.default.isArray(insertion)) {
        input = _lodash2.default.map(insertion, function (obj) {
          if (_lodash2.default.isFunction(obj.$toDatabaseJson)) {
            return obj.$toDatabaseJson();
          } else {
            return obj;
          }
        });
      } else if (_lodash2.default.isFunction(insertion.$toDatabaseJson)) {
        input = insertion.$toDatabaseJson();
      }

      return (0, _get4.default)((0, _getPrototypeOf2.default)(QueryBuilder.prototype), 'insert', this).call(this, input);
    }

    /**
     * Creates an update query.
     *
     * The update object is validated against the model's `jsonSchema`. If validation fails
     * the Promise is rejected with a `ValidationError`.
     *
     * This method is meant for updating _whole_ objects with all required properties. If you
     * want to update a subset of properties use the `patch()` method.
     *
     * NOTE: The return value of the query will be the number of affected rows. If you want
     * the updated row as a result, you may want to use the `updateAndFetchById` method.
     *
     * Examples:
     *
     * ```js
     * Person
     *   .query()
     *   .update({firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .where('id', 134)
     *   .then(function (numberOfAffectedRows) {
     *     console.log(numberOfAffectedRows);
     *   });
     * ```
     *
     * You can also give raw expressions and subqueries as values like this:
     *
     * ```js
     * Person
     *   .query()
     *   .update({
     *     firstName: Person.raw("'Jenni' || 'fer'"),
     *     lastName: 'Lawrence',
     *     age: Person.query().avg('age')
     *   });
     * ```
     *
     * @param {Model|Object=} modelOrObject
     *    The update object.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'update',
    value: function update(modelOrObject) {
      return this.$$updateWithOptions(modelOrObject, 'update', {});
    }

    /**
     * Updates a single model by id and fetches it from the database afterwards.
     *
     * The update object is validated against the model's `jsonSchema`. If validation fails
     * the Promise is rejected with a `ValidationError`.
     *
     * This method is meant for updating _whole_ objects with all required properties. If you
     * want to update a subset of properties use the `patchAndFetchById()` method.
     *
     * Examples:
     *
     * ```js
     * Person
     *   .query()
     *   .updateAndFetchById(134, {firstName: 'Jennifer', lastName: 'Lawrence', age: 24})
     *   .then(function (updatedModel) {
     *     console.log(updatedModel.firstName);
     *   });
     * ```
     *
     * You can also give raw expressions and subqueries as values like this:
     *
     * ```js
     * Person
     *   .query()
     *   .updateAndFetchById(134, {
     *     firstName: Person.raw("'Jenni' || 'fer'"),
     *     lastName: 'Lawrence',
     *     age: Person.query().avg('age')
     *   });
     * ```
     *
     * @param {number|string|Array.<number|string>} id
     *    The identifier of the object to update.
     *
     * @param {Model|Object=} modelOrObject
     *    The update object.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'updateAndFetchById',
    value: function updateAndFetchById(id, modelOrObject) {
      return this.$$updateWithOptions(modelOrObject, 'update', {}, id).whereComposite(this._modelClass.getFullIdColumn(), id);
    }

    /**
     * @private
     */

  }, {
    key: '$$updateWithOptions',
    value: function $$updateWithOptions(modelOrObject, method, modelOptions, fetchId) {
      var ModelClass = this._modelClass;

      var update = new _InsertionOrUpdate2.default({
        ModelClass: ModelClass,
        modelOptions: modelOptions,
        modelsOrObjects: modelOrObject
      });

      this.$$callWriteMethodImpl(method, [update, this]);

      this.runBefore(function (result, builder) {
        return update.model().$beforeUpdate(modelOptions, builder.context());
      });

      this.runAfterModelCreate(function (numUpdated, builder) {
        var promise = undefined;

        if (fetchId) {
          promise = ModelClass.query().first().childQueryOf(builder).whereComposite(ModelClass.getFullIdColumn(), fetchId).then(function (model) {
            return model ? update.model().$set(model) : null;
          });
        } else {
          promise = _bluebird2.default.resolve(numUpdated);
        }

        return promise.then(function (result) {
          return [result, update.model().$afterUpdate(modelOptions, builder.context())];
        }).spread(function (result) {
          return result;
        });
      });

      return this;
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: '$$update',
    value: function $$update(update) {
      var input = update;
      var idColumn = this._modelClass.idColumn;

      if (update instanceof _InsertionOrUpdate2.default) {
        input = update.toKnexInput();
      } else if (_lodash2.default.isFunction(update.$toDatabaseJson)) {
        input = update.$toDatabaseJson();
      }

      // We never want to update the identifier.
      if (_lodash2.default.isArray(idColumn)) {
        _lodash2.default.each(idColumn, function (col) {
          delete input[col];
        });
      } else {
        delete input[idColumn];
      }

      return (0, _get4.default)((0, _getPrototypeOf2.default)(QueryBuilder.prototype), 'update', this).call(this, input);
    }

    /**
     * Creates an patch query.
     *
     * The patch object is validated against the model's `jsonSchema` _but_ the `required` property
     * of the `jsonSchema` is ignored. This way the properties in the patch object are still validated
     * but an error isn't thrown if the patch object doesn't contain all required properties.
     *
     * If validation fails the Promise is rejected with a `ValidationError`.
     *
     * NOTE: The return value of the query will be the number of affected rows. If you want
     * the updated row as a result, you may want to use the `patchAndFetchById` method.
     *
     * Examples:
     *
     * ```js
     * Person
     *   .query()
     *   .patch({age: 24})
     *   .where('id', 134)
     *   .then(function (numberOfAffectedRows) {
     *     console.log(numberOfAffectedRows);
     *   });
     * ```
     *
     * You can also give raw expressions and subqueries as values like this:
     *
     * ```js
     * Person
     *   .query()
     *   .patch({
     *     age: Person.query().avg('age'),
     *     firstName: Person.raw("'Jenni' || 'fer'")
     *   });
     * ```
     *
     * @param {Model|Object=} modelOrObject
     *    The patch object.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'patch',
    value: function patch(modelOrObject) {
      return this.$$updateWithOptions(modelOrObject, 'patch', { patch: true });
    }

    /**
     * Patches a single model by id and fetches it from the database afterwards.
     *
     * The patch object is validated against the model's `jsonSchema` _but_ the `required` property
     * of the `jsonSchema` is ignored. This way the properties in the patch object are still validated
     * but an error isn't thrown if the patch object doesn't contain all required properties.
     *
     * If validation fails the Promise is rejected with a `ValidationError`.
     *
     * Examples:
     *
     * ```js
     * Person
     *   .query()
     *   .patchAndFetchById(134, {age: 24})
     *   .then(function (updatedModel) {
     *     console.log(updatedModel.firstName);
     *   });
     * ```
     *
     * You can also give raw expressions and subqueries as values like this:
     *
     * ```js
     * Person
     *   .query()
     *   .patchAndFetchById(134, {
     *     age: Person.query().avg('age'),
     *     firstName: Person.raw("'Jenni' || 'fer'")
     *   });
     * ```
     *
     * @param {number|string|Array.<number|string>} id
     *    The identifier of the object to update.
     *
     * @param {Model|Object=} modelOrObject
     *    The update object.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'patchAndFetchById',
    value: function patchAndFetchById(id, modelOrObject) {
      return this.$$updateWithOptions(modelOrObject, 'patch', { patch: true }, id).whereComposite(this._modelClass.getFullIdColumn(), id);
    }

    /**
     * Creates a delete query.
     *
     * Examples:
     *
     * ```js
     * Person
     *   .query()
     *   .delete()
     *   .where('age', '>', 100)
     *   .then(function (numberOfDeletedRows) {
     *     console.log('removed', numberOfDeletedRows, 'people');
     *   });
     * ```
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'delete',
    value: function _delete() {
      this.$$callWriteMethodImpl('delete', [this]);
      return this;
    }

    /**
     * Alias for delete.
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'del',
    value: function del() {
      return this.delete();
    }

    /**
     * Delete a model by id.
     *
     * ```js
     * Person.query().deleteById(1);
     * ```
     *
     * Composite key:
     *
     * ```js
     * Person.query().deleteById([1, '2', 10]);
     * ```
     *
     * @param {*|Array.<*>} id
     * @returns {QueryBuilder}
     */

  }, {
    key: 'deleteById',
    value: function deleteById(id) {
      return this.delete().whereComposite(this._modelClass.getFullIdColumn(), id);
    }

    /**
     * @ignore
     * @returns {QueryBuilder}
     */

  }, {
    key: '$$delete',
    value: function $$delete() {
      return (0, _get4.default)((0, _getPrototypeOf2.default)(QueryBuilder.prototype), 'delete', this).call(this);
    }

    /**
     * Relates an existing model to another model.
     *
     * This method doesn't create a new instance but only updates the foreign keys and in
     * the case of ManyToMany relation, creates a join row to the join table.
     *
     * On Postgres multiple models can be related by giving an array of identifiers.
     *
     * ```js
     * Person
     *   .query()
     *   .where('id', 123)
     *   .first()
     *   .then(function (person) {
     *     return person.$relatedQuery('movies').relate(50);
     *   })
     *   .then(function () {
     *     console.log('movie 50 is now related to person 123 through `movies` relation');
     *   });
     * ```
     *
     * Composite key:
     *
     * ```js
     * Person
     *   .query()
     *   .where('id', 123)
     *   .first()
     *   .then(function (person) {
     *     return person.$relatedQuery('movies').relate([50, 20, 10]);
     *   })
     *   .then(function () {
     *     console.log('movie 50 is now related to person 123 through `movies` relation');
     *   });
     * ```
     *
     * Multiple models with composite key (postgres only):
     *
     * ```js
     * Person
     *   .query()
     *   .where('id', 123)
     *   .first()
     *   .then(function (person) {
     *     return person.$relatedQuery('movies').relate([[50, 20, 10], [24, 46, 12]]);
     *   })
     *   .then(function () {
     *     console.log('movie 50 is now related to person 123 through `movies` relation');
     *   });
     * ```
     *
     * @param {number|string|Array.<number|string>|Array.<Array.<number|string>>} ids
     * @returns {QueryBuilder}
     */

  }, {
    key: 'relate',
    value: function relate(ids) {
      this.$$callWriteMethodImpl('relate', [ids, this]);
      return this.runAfterModelCreate(function () {
        return ids;
      });
    }

    /**
     * Removes a connection between two models.
     *
     * Doesn't delete the models. Only removes the connection. For ManyToMany relations this
     * deletes the join column from the join table. For other relation types this sets the
     * join columns to null.
     *
     * ```js
     * Person
     *   .query()
     *   .where('id', 123)
     *   .first()
     *   .then(function (person) {
     *     return person.$relatedQuery('movies').unrelate().where('id', 50);
     *   })
     *   .then(function () {
     *     console.log('movie 50 is no longer related to person 123 through `movies` relation');
     *   });
     * ```
     *
     * @returns {QueryBuilder}
     */

  }, {
    key: 'unrelate',
    value: function unrelate() {
      this.$$callWriteMethodImpl('unrelate', [this]);
      this.runAfterModelCreate(function () {
        return {};
      });
      return this;
    }

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilder}
     */

  }, {
    key: 'increment',
    value: function increment(propertyName, howMuch) {
      var patch = {};
      var columnName = this._modelClass.propertyNameToColumnName(propertyName);
      patch[propertyName] = this._modelClass.knex().raw('?? + ?', [columnName, howMuch]);
      return this.patch(patch);
    }

    /**
     * See <a href="http://knexjs.org">knex documentation</a>
     * @returns {QueryBuilder}
     */

  }, {
    key: 'decrement',
    value: function decrement(propertyName, howMuch) {
      var patch = {};
      var columnName = this._modelClass.propertyNameToColumnName(propertyName);
      patch[propertyName] = this._modelClass.knex().raw('?? - ?', [columnName, howMuch]);
      return this.patch(patch);
    }

    /**
     * @private
     */

  }, {
    key: '$$callWriteMethodImpl',
    value: function $$callWriteMethodImpl(method, args) {
      this._calledWriteMethod = 'method';
      return this._customImpl[method].apply(this, args);
    }
  }], [{
    key: 'forClass',
    value: function forClass(modelClass) {
      return new this(modelClass);
    }
  }]);
  return QueryBuilder;
}(_QueryBuilderBase3.default), (_applyDecoratedDescriptor(_class.prototype, 'dumpSql', [_dec], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'dumpSql'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'insert', [writeQueryMethod], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'insert'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'insertWithRelated', [writeQueryMethod], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'insertWithRelated'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '$$updateWithOptions', [writeQueryMethod], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '$$updateWithOptions'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'delete', [writeQueryMethod], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'delete'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'relate', [writeQueryMethod], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'relate'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unrelate', [writeQueryMethod], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'unrelate'), _class.prototype)), _class));

/**
 * @private
 */

exports.default = QueryBuilder;
function writeQueryMethod(target, property, descriptor) {
  descriptor.value = tryCallWriteMethod(descriptor.value);
}

/**
 * @private
 */
function tryCallWriteMethod(func) {
  return function () {
    if (this._calledWriteMethod) {
      this.reject(new Error('Double call to a write method. ' + 'You can only call one of the write methods ' + '(insert, update, patch, delete, relate, unrelate, increment, decrement) ' + 'and only once per query builder.'));
      return this;
    }

    try {
      func.apply(this, arguments);
    } catch (err) {
      this.reject(err);
    }

    return this;
  };
}

/**
 * @private
 */
function checkEager(builder) {
  if (builder._eagerExpression && builder._allowedEagerExpression) {
    if (!builder._allowedEagerExpression.isSubExpression(builder._eagerExpression)) {
      builder.reject(new _ValidationError2.default({ eager: 'eager expression not allowed' }));
    }
  }
}

/**
 * @private
 */
function createModels(builder, result) {
  if (_lodash2.default.isNull(result) || _lodash2.default.isUndefined(result)) {
    return null;
  }

  if (_lodash2.default.isArray(result)) {
    if (result.length > 0 && _lodash2.default.isObject(result[0])) {
      for (var i = 0, l = result.length; i < l; ++i) {
        result[i] = builder._modelClass.fromDatabaseJson(result[i]);
      }
    }
  } else if (_lodash2.default.isObject(result)) {
    result = builder._modelClass.fromDatabaseJson(result);
  }

  return result;
}

/**
 * @private
 */
function eagerFetch(builder, $models) {
  if ($models instanceof builder._modelClass || _lodash2.default.isArray($models) && $models[0] instanceof builder._modelClass) {
    return new _EagerFetcher2.default({
      modelClass: builder._modelClass,
      models: builder._modelClass.ensureModelArray($models),
      eager: builder._eagerExpression,
      filters: builder._eagerFilters,
      rootQuery: builder
    }).fetch().then(function (models) {
      return _lodash2.default.isArray($models) ? models : models[0];
    });
  } else {
    return $models;
  }
}

/**
 * @private
 */
function _build(builder) {
  var context = builder.context() || {};

  if (!builder.has(/from|table|into/)) {
    // Set the table only if it hasn't been explicitly set yet.
    builder.table(builder._modelClass.tableName);
  }

  if (_lodash2.default.isFunction(context.onBuild)) {
    context.onBuild.call(builder, builder);
  }

  _lodash2.default.forEach(builder._hooks.onBuild, function (func) {
    func.call(builder, builder);
  });

  // noinspection JSUnresolvedVariable
  return _QueryBuilderBase3.default.prototype.build.call(builder);
}

/**
 * @private
 */
function batchInsert(models, queryBuilder, batchSize) {
  var batches = _lodash2.default.chunk(models, batchSize);
  return _lodash2.default.map(batches, function (batch) {
    return queryBuilder.clone().insert(batch);
  });
}