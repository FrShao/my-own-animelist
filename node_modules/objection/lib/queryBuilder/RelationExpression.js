'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _relationExpressionParser = require('./parsers/relationExpressionParser');

var _relationExpressionParser2 = _interopRequireDefault(_relationExpressionParser);

var _ValidationError = require('./../ValidationError');

var _ValidationError2 = _interopRequireDefault(_ValidationError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Relation expression is a simple DSL for expressing relation trees.
 *
 * For example an expression `children.[movies.actors.[pets, children], pets]` represents a tree:
 *
 * ```
 *               children
 *               (Person)
 *                  |
 *          -----------------
 *          |               |
 *        movies           pets
 *       (Movie)         (Animal)
 *          |
 *        actors
 *       (Person)
 *          |
 *     -----------
 *     |         |
 *    pets    children
 *  (Animal)  (Person)
 *
 * ```
 *
 * The model classes are shown in parenthesis.
 *
 * This class rarely needs to be used directly. The relation expression can be given to a bunch
 * of functions in objection.js. For example:
 *
 * ```js
 * Person
 *   .query()
 *   .eager('children.[movies.actors.[pets, children], pets]')
 *   .then(function (persons) {
 *     // All persons have the given relation tree fetched.
 *     console.log(persons[0].children[0].movies[0].actors[0].pets[0].name);
 *   });
 * ```
 *
 * There are two tokens that have special meaning: `*` and `^`. `*` means "all relations recursively" and
 * `^` means "this relation recursively".
 *
 * For example `children.*` means "relation `children` and all its relations, and all their relations and ...".
 * The `*` token must be used with caution or you will end up fetching your entire database.
 *
 * Expression `parent.^` is equivalent to `parent.parent.parent.parent...` up to the point a relation no longer
 * has results for the `parent` relation.
 *
 * Relation expressions can also have arguments. Arguments are listed in parenthesis after the relation names
 * like this:
 *
 * ```js
 * children(arg1, arg2).[movies.actors(arg3), pets]
 * ```
 *
 * In this example `children` relation had arguments `arg1` and `arg2` and `actors` relation had
 * the argument `arg3`.
 */

var RelationExpression = function () {
  function RelationExpression(node) {
    (0, _classCallCheck3.default)(this, RelationExpression);

    node = node || {};
    this.name = node.name || null;
    this.args = node.args || [];
    this.numChildren = node.numChildren || 0;
    this.children = node.children || {};
  }

  /**
   * Parses an expression string into a {@link RelationExpression} object.
   *
   * @param {string|RelationExpression} expr
   * @returns {RelationExpression}
   */

  (0, _createClass3.default)(RelationExpression, [{
    key: 'isSubExpression',

    /**
     * Tests if another expression is a sub expression of this one.
     *
     * Expression B is a sub expression of expression A if:
     *
     * - A and B have the same root
     * - And each path from root to a leaf in B can be found in A
     *
     * For example sub expressions of `children.[movies.actors, pets]` are:
     *
     * - `children`
     * - `children.movies`
     * - `children.pets`
     * - `children.movies.actors`
     * - `children.[movies, pets]`
     * - `children.[movies.actors, pets]`
     *
     * @param {string|RelationExpression} expr
     * @returns {boolean}
     */
    value: function isSubExpression(expr) {
      var _this = this;

      expr = RelationExpression.parse(expr);

      if (this.isAllRecursive()) {
        return true;
      }

      if (expr.isAllRecursive()) {
        return this.isAllRecursive();
      }

      if (this.name !== expr.name) {
        return false;
      }

      if (expr.isRecursive()) {
        return this.isAllRecursive() || this.isRecursive();
      }

      return _lodash2.default.all(expr.children, function (child, childName) {
        var ownSubExpression = _this.childExpression(childName);
        var subExpression = expr.childExpression(childName);

        return ownSubExpression && ownSubExpression.isSubExpression(subExpression);
      });
    }

    /**
     * @ignore
     * @returns {boolean}
     */

  }, {
    key: 'isRecursive',
    value: function isRecursive() {
      return !!_lodash2.default.find(this.children, { name: '^' });
    }

    /**
     * @ignore
     * @returns {boolean}
     */

  }, {
    key: 'isAllRecursive',
    value: function isAllRecursive() {
      return this.numChildren === 1 && this.children[(0, _keys2.default)(this.children)[0]].name === '*';
    }

    /**
     * @ignore
     * @returns {RelationExpression}
     */

  }, {
    key: 'childExpression',
    value: function childExpression(childName) {
      if (this.isAllRecursive() || this.isRecursive() && childName === this.name) {
        return this;
      }

      if (this.children[childName]) {
        return new RelationExpression(this.children[childName]);
      } else {
        return null;
      }
    }

    /**
     * @ignore
     */

  }, {
    key: 'forEachChild',
    value: function forEachChild(cb) {
      _lodash2.default.each(this.children, function (child, childName) {
        if (childName !== '*' && childName !== '^') {
          cb(child, childName);
        }
      });
    }
  }], [{
    key: 'parse',
    value: function parse(expr) {
      if (expr instanceof RelationExpression) {
        return expr;
      } else if (!_lodash2.default.isString(expr) || _lodash2.default.isEmpty(expr.trim())) {
        return new RelationExpression();
      } else {
        try {
          return new RelationExpression(_relationExpressionParser2.default.parse(expr));
        } catch (err) {
          throw new _ValidationError2.default({
            message: 'Invalid relation expression "' + expr + '"',
            cause: err.message
          });
        }
      }
    }
  }]);
  return RelationExpression;
}();

exports.default = RelationExpression;