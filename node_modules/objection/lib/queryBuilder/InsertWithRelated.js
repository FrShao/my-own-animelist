'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _RelationExpression = require('./RelationExpression');

var _RelationExpression2 = _interopRequireDefault(_RelationExpression);

var _ManyToManyRelation = require('../relations/ManyToManyRelation');

var _ManyToManyRelation2 = _interopRequireDefault(_ManyToManyRelation);

var _OneToManyRelation = require('../relations/OneToManyRelation');

var _OneToManyRelation2 = _interopRequireDefault(_OneToManyRelation);

var _OneToOneRelation = require('../relations/OneToOneRelation');

var _OneToOneRelation2 = _interopRequireDefault(_OneToOneRelation);

var _ValidationError = require('../ValidationError');

var _ValidationError2 = _interopRequireDefault(_ValidationError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Model = undefined;

/**
 * Given an model with nested relations, finds a fast way to insert the models into
 * database so that not-null constraints are not broken.
 *
 * @ignore
 */

var InsertWithRelated = function () {
  function InsertWithRelated(_ref) {
    var modelClass = _ref.modelClass;
    var models = _ref.models;
    var allowedRelations = _ref.allowedRelations;
    (0, _classCallCheck3.default)(this, InsertWithRelated);

    // Lazy-load Model.
    Model = Model || require('./../model/Model').default;

    this.modelClass = modelClass;
    this.models = models;
    this.allowedRelations = allowedRelations || null;
    this.done = false;
    this.graph = this._buildDependencyGraph();
  }

  /**
   * @param {function(TableInsertion)} inserter
   * @return {Promise}
   */

  (0, _createClass3.default)(InsertWithRelated, [{
    key: 'execute',
    value: function execute(inserter) {
      return this._executeNextBatch(inserter);
    }

    /**
     * @returns {DependencyGraph}
     * @private
     */

  }, {
    key: '_buildDependencyGraph',
    value: function _buildDependencyGraph() {
      var graph = new DependencyGraph(this.allowedRelations);
      graph.build(this.modelClass, this.models);
      return graph;
    }

    /**
     * @param {function(TableInsertion)} inserter
     * @returns {Promise}
     * @private
     */

  }, {
    key: '_executeNextBatch',
    value: function _executeNextBatch(inserter) {
      var _this = this;

      var batch = this._nextBatch();

      if (!batch) {
        // If we get here, we are done. All we need to do now is to finalize the object graph
        // and return it as the final output.
        return this._finalize();
      }

      // Insert the batch using the `inserter` function.
      return _bluebird2.default.all(_lodash2.default.map(batch, function (tableInsertion) {
        var uids = undefined;

        if (!tableInsertion.isJoinTableInsertion) {
          // We need to omit the uid properties so that they don't get inserted
          // into the database. Join table insertions never have uids.
          uids = _this._omitUids(tableInsertion);
        }

        return inserter(tableInsertion).then(function () {
          if (!tableInsertion.isJoinTableInsertion) {
            // Resolve dependencies to the inserted objects.
            _this._resolveDepsForInsertion(tableInsertion, uids);
          }
        });
      })).then(function () {
        return _this._executeNextBatch(inserter);
      });
    }

    /**
     * @private
     * @returns {Object.<string, TableInsertion>}
     */

  }, {
    key: '_nextBatch',
    value: function _nextBatch() {
      if (this.done) {
        return null;
      }

      var batch = this._createBatch();

      if (_lodash2.default.isEmpty(batch)) {
        this.done = true;
        return this._createManyToManyRelationJoinRowBatch();
      } else {
        this._markBatchHandled(batch);
        return batch;
      }
    }

    /**
     * @private
     * @returns {Object.<string, TableInsertion>}
     */

  }, {
    key: '_createBatch',
    value: function _createBatch() {
      var batch = (0, _create2.default)(null);
      var nodes = this.graph.nodes;

      for (var n = 0, ln = nodes.length; n < ln; ++n) {
        var node = nodes[n];

        if (!node.handled && node.needs.length === node.numHandledNeeds) {
          var tableInsertion = getTableInsertion(batch, node.modelClass.tableName);

          if (!tableInsertion) {
            tableInsertion = new TableInsertion(node.modelClass, false);
            setTableInsertion(batch, node.modelClass.tableName, tableInsertion);
          }

          tableInsertion.models.push(node.model);
          tableInsertion.isInputModel.push(isInputNode(this.graph.inputNodesById, node));
        }
      }

      return batch;
    }

    /**
     * @private
     * @param {Object.<string, TableInsertion>} batch
     */

  }, {
    key: '_markBatchHandled',
    value: function _markBatchHandled(batch) {
      var models = _lodash2.default.flatten(_lodash2.default.pluck(batch, 'models'));
      var nodes = this.graph.nodesById;

      for (var m = 0, lm = models.length; m < lm; ++m) {
        var id = getUid(models[m]);
        var node = getNode(nodes, id);

        for (var nb = 0, lnb = node.isNeededBy.length; nb < lnb; ++nb) {
          var dep = node.isNeededBy[nb];
          dep.node.numHandledNeeds++;
        }

        node.handled = true;
      }
    }

    /**
     * @private
     * @returns {Object.<string, TableInsertion>}
     */

  }, {
    key: '_createManyToManyRelationJoinRowBatch',
    value: function _createManyToManyRelationJoinRowBatch() {
      var batch = (0, _create2.default)(null);

      for (var n = 0, ln = this.graph.nodes.length; n < ln; ++n) {
        var node = this.graph.nodes[n];

        for (var m = 0, lm = node.manyToManyConnections.length; m < lm; ++m) {
          var conn = node.manyToManyConnections[m];
          var tableInsertion = getTableInsertion(batch, conn.relation.joinTable);

          var sourceVal = node.model.$values(conn.relation.ownerProp);
          var targetVal = conn.node.model.$values(conn.relation.relatedProp);

          var joinModel = {};
          var knex = conn.relation.ownerModelClass.knex();
          var modelClass = conn.relation.joinTableModelClass;

          if (knex) {
            // TODO: Because the joinTableModelClass may have been created inside ManyToManyRelation, it may not be bound. We really should not have to know about it here...
            modelClass = modelClass.bindKnex(knex);
          }

          for (var i = 0; i < sourceVal.length; ++i) {
            joinModel[conn.relation.joinTableOwnerProp[i]] = sourceVal[i];
          }

          for (var i = 0; i < targetVal.length; ++i) {
            joinModel[conn.relation.joinTableRelatedProp[i]] = targetVal[i];
          }

          joinModel = modelClass.fromJson(joinModel);

          if (!tableInsertion) {
            tableInsertion = new TableInsertion(modelClass, true);
            setTableInsertion(batch, modelClass.tableName, tableInsertion);
          }

          tableInsertion.models.push(joinModel);
          tableInsertion.isInputModel.push(false);
        }
      }

      // Remove duplicates.
      _lodash2.default.each(batch, function (tableInsertion) {
        if (tableInsertion.models.length) {
          (function () {
            var keys = _lodash2.default.keys(tableInsertion.models[0]);
            tableInsertion.models = _lodash2.default.unique(tableInsertion.models, function (model) {
              return model.$values(keys).join();
            });
            tableInsertion.isInputModel = _lodash2.default.times(tableInsertion.models.length, _lodash2.default.constant(false));
          })();
        }
      });

      return batch;
    }

    /**
     * @private
     */

  }, {
    key: '_omitUids',
    value: function _omitUids(tableInsertion) {
      var ids = _lodash2.default.pluck(tableInsertion.models, tableInsertion.modelClass.uidProp);

      for (var m = 0, lm = tableInsertion.models.length; m < lm; ++m) {
        tableInsertion.models[m].$omit(tableInsertion.modelClass.uidProp);
      }

      return ids;
    }

    /**
     * @private
     * @param {TableInsertion} tableInsertion
     * @param {Array.<string>} uids
     */

  }, {
    key: '_resolveDepsForInsertion',
    value: function _resolveDepsForInsertion(tableInsertion, uids) {
      for (var m = 0, lm = tableInsertion.models.length; m < lm; ++m) {
        var node = getNode(this.graph.nodesById, uids[m]);
        var model = tableInsertion.models[m];

        for (var d = 0, ld = node.isNeededBy.length; d < ld; ++d) {
          var dep = node.isNeededBy[d];
          dep.resolve(model);
        }
      }
    }

    /**
     * @private
     * @return {Promise}
     */

  }, {
    key: '_finalize',
    value: function _finalize() {
      var _this2 = this;

      var _loop = function _loop(n, ln) {
        var refNode = _this2.graph.nodes[n];
        var ref = getUidRef(refNode.model);

        if (ref) {
          (function () {
            // Copy all the properties to the reference nodes.
            var actualNode = getNode(_this2.graph.nodesById, ref);
            var relations = actualNode.modelClass.getRelations();

            _lodash2.default.each(actualNode.model, function (value, key) {
              if (!getRelation(relations, key) && !_lodash2.default.isFunction(value)) {
                refNode.model[key] = value;
              }
            });

            refNode.model.$omit(refNode.modelClass.uidProp, refNode.modelClass.uidRefProp);
          })();
        }
      };

      for (var n = 0, ln = this.graph.nodes.length; n < ln; ++n) {
        _loop(n, ln);
      }

      return _bluebird2.default.resolve(this.models);
    }
  }]);
  return InsertWithRelated;
}();

exports.default = InsertWithRelated;

function TableInsertion(modelClass, isJoinTableInsertion) {
  this.modelClass = modelClass;
  this.isJoinTableInsertion = isJoinTableInsertion;
  this.models = [];
  this.isInputModel = [];
}

function DependencyNode(model, modelClass) {
  this.id = getUid(model);
  this.model = model;
  this.modelClass = modelClass;

  this.needs = [];
  this.isNeededBy = [];
  this.manyToManyConnections = [];

  this.numHandledNeeds = 0;
  this.handled = false;
  this.visited = false;
  this.recursion = false;
}

function Dependency(node, resolve) {
  this.node = node;
  this.resolve = resolve;
}

function ManyToManyConnection(node, relation) {
  this.node = node;
  this.relation = relation;
}

function DependencyGraph(allowedRelations) {
  this.allowedRelations = allowedRelations;
  this.nodesById = (0, _create2.default)(null);
  this.inputNodesById = (0, _create2.default)(null);
  this.nodes = [];
  this.uid = 0;
}

DependencyGraph.prototype.build = function (modelClass, models) {
  var self = this;

  this.nodesById = (0, _create2.default)(null);
  this.nodes = [];

  if (_lodash2.default.isArray(models)) {
    _lodash2.default.each(models, function (model) {
      self.buildForModel(modelClass, model, null, null, self.allowedRelations);
    });
  } else {
    this.buildForModel(modelClass, models, null, null, this.allowedRelations);
  }

  this.solveReferences();
  this.createNonRelationDeps();

  if (this.isCyclic(this.nodes)) {
    throw new _ValidationError2.default({ cyclic: 'the object graph contains cyclic references' });
  }

  return this.nodes;
};

DependencyGraph.prototype.buildForModel = function (modelClass, model, parentNode, rel, allowedRelations) {
  if (!(model instanceof Model)) {
    throw new _ValidationError2.default({ notModel: 'the object graph contains cyclic references' });
  }

  if (!getUid(model)) {
    setUid(model, '__objection_uid(' + ++this.uid + ')__');
  }

  var node = new DependencyNode(model, modelClass);

  this.nodesById[node.id] = node;
  this.nodes.push(node);

  if (!parentNode) {
    this.inputNodesById[node.id] = node;
  }

  if (rel instanceof _OneToManyRelation2.default) {

    node.needs.push(new Dependency(parentNode, function (model) {
      for (var i = 0; i < rel.relatedProp.length; ++i) {
        model[rel.relatedProp[i]] = this.node.model[rel.ownerProp[i]];
      }
    }));

    parentNode.isNeededBy.push(new Dependency(node, function (model) {
      for (var i = 0; i < rel.relatedProp.length; ++i) {
        this.node.model[rel.relatedProp[i]] = model[rel.ownerProp[i]];
      }
    }));
  } else if (rel instanceof _OneToOneRelation2.default) {

    node.isNeededBy.push(new Dependency(parentNode, function (model) {
      for (var i = 0; i < rel.relatedProp.length; ++i) {
        this.node.model[rel.ownerProp[i]] = model[rel.relatedProp[i]];
      }
    }));

    parentNode.needs.push(new Dependency(node, function (model) {
      for (var i = 0; i < rel.relatedProp.length; ++i) {
        model[rel.ownerProp[i]] = this.node.model[rel.relatedProp[i]];
      }
    }));
  } else if (rel instanceof _ManyToManyRelation2.default) {
    // ManyToManyRelations create no dependencies since we can create the
    // join table rows after everything else has been inserted.
    parentNode.manyToManyConnections.push(new ManyToManyConnection(node, rel));
  } else if (rel) {
    throw new Error('unsupported relation type "' + (rel.constructor && rel.constructor.name) + '"');
  }

  this.buildForRelations(modelClass, model, node, allowedRelations);
};

DependencyGraph.prototype.buildForRelations = function (modelClass, model, node, allowedRelations) {
  var relations = modelClass.getRelations();

  for (var relName in relations) {
    var rel = getRelation(relations, relName);
    var relModels = getRelated(model, relName);
    var nextAllowed = null;

    if (relModels && allowedRelations instanceof _RelationExpression2.default) {
      nextAllowed = allowedRelations.childExpression(relName);

      if (!nextAllowed) {
        throw new _ValidationError2.default({ allowedRelations: 'trying to insert an unallowed relation' });
      }
    }

    if (_lodash2.default.isArray(relModels)) {
      for (var i = 0, l = relModels.length; i < l; ++i) {
        this.buildForModel(rel.relatedModelClass, relModels[i], node, rel, nextAllowed);
      }
    } else if (relModels) {
      this.buildForModel(rel.relatedModelClass, relModels, node, rel, nextAllowed);
    }
  }
};

DependencyGraph.prototype.solveReferences = function () {
  var refMap = (0, _create2.default)(null);

  // First merge all reference nodes into the actual node.
  this.mergeReferences(refMap);

  // Replace all reference nodes with the actual nodes.
  this.replaceReferenceNodes(refMap);
};

DependencyGraph.prototype.mergeReferences = function (refMap) {
  for (var n = 0, ln = this.nodes.length; n < ln; ++n) {
    var _refNode = this.nodes[n];

    if (_refNode.handled) {
      continue;
    }

    var _ref2 = getUidRef(_refNode.model);

    if (_ref2) {
      var actualNode = getNode(this.nodesById, _ref2);

      if (!actualNode) {
        throw new _ValidationError2.default({ ref: 'could not resolve reference "' + _ref2 + '"' });
      }

      var d = undefined,
          ld = undefined;

      for (d = 0, ld = _refNode.needs.length; d < ld; ++d) {
        actualNode.needs.push(_refNode.needs[d]);
      }

      for (d = 0, ld = _refNode.isNeededBy.length; d < ld; ++d) {
        actualNode.isNeededBy.push(_refNode.isNeededBy[d]);
      }

      for (var m = 0, lm = _refNode.manyToManyConnections.length; m < lm; ++m) {
        actualNode.manyToManyConnections.push(_refNode.manyToManyConnections[m]);
      }

      setRefMap(refMap, _refNode.id, actualNode);

      _refNode.handled = true;
    }
  }
};

DependencyGraph.prototype.replaceReferenceNodes = function (refMap) {
  for (var n = 0, ln = this.nodes.length; n < ln; ++n) {
    var node = this.nodes[n];
    var d = undefined,
        ld = undefined,
        dep = undefined,
        actualNode = undefined;

    for (d = 0, ld = node.needs.length; d < ld; ++d) {
      dep = node.needs[d];
      actualNode = getRefMap(refMap, dep.node.id);

      if (actualNode) {
        dep.node = actualNode;
      }
    }

    for (d = 0, ld = node.isNeededBy.length; d < ld; ++d) {
      dep = node.isNeededBy[d];
      actualNode = getRefMap(refMap, dep.node.id);

      if (actualNode) {
        dep.node = actualNode;
      }
    }

    for (var m = 0, lm = node.manyToManyConnections.length; m < lm; ++m) {
      var conn = node.manyToManyConnections[m];
      actualNode = getRefMap(refMap, conn.node.id);

      if (actualNode) {
        conn.node = actualNode;
      }
    }
  }
};

DependencyGraph.prototype.createNonRelationDeps = function () {
  for (var n = 0, ln = this.nodes.length; n < ln; ++n) {
    var node = this.nodes[n];

    if (!node.handled) {
      this.createNonRelationDepsForObject(node.model, node, []);
    }
  }
};

DependencyGraph.prototype.createNonRelationDepsForObject = function (obj, node, path) {
  var propRefRegex = node.modelClass.propRefRegex;
  var relations = node.modelClass.getRelations();
  var isModel = obj instanceof Model;
  var self = this;

  _lodash2.default.each(obj, function (value, key) {
    if (isModel && getRelation(relations, key)) {
      // Don't traverse the relations of model instances.
      return;
    }

    path.push(key);

    if (_lodash2.default.isString(value)) {
      allMatches(propRefRegex, value, function (matchResult) {
        var match = matchResult[0];
        var refId = matchResult[1];
        var refProp = matchResult[2];
        var pathClone = path.slice();
        var refNode = self.nodesById[refId];

        if (!refNode) {
          throw new _ValidationError2.default({ ref: 'could not resolve reference "' + value + '"' });
        }

        if (value === match) {
          // If the match is the whole string, replace the value with the resolved value.
          // This means that the value will have the same type as the resolved value
          // (date, number, etc).
          node.needs.push(new Dependency(refNode, function (model) {
            _lodash2.default.set(model, pathClone, this.node.model[refProp]);
          }));
          refNode.isNeededBy.push(new Dependency(node, function (model) {
            _lodash2.default.set(this.node.model, pathClone, model[refProp]);
          }));
        } else {
          // If the match is inside a string, replace the reference inside the string with
          // the resolved value.
          node.needs.push(new Dependency(refNode, function (model) {
            value = value.replace(match, this.node.model[refProp]);
            _lodash2.default.set(model, pathClone, value);
          }));
          refNode.isNeededBy.push(new Dependency(node, function (model) {
            value = value.replace(match, model[refProp]);
            _lodash2.default.set(this.node.model, pathClone, value);
          }));
        }
      });
    } else if (_lodash2.default.isObject(value)) {
      self.createNonRelationDepsForObject(value, node, path);
    }

    path.pop();
  });
};

DependencyGraph.prototype.isCyclic = function (nodes) {
  var isCyclic = false;

  for (var n = 0, ln = nodes.length; n < ln; ++n) {
    var node = nodes[n];

    if (node.handled) {
      return;
    }

    if (this.isCyclicNode(node)) {
      isCyclic = true;
      break;
    }
  }

  this.clearFlags(this.nodes);
  return isCyclic;
};

DependencyGraph.prototype.isCyclicNode = function (node) {
  if (!node.visited) {
    node.visited = true;
    node.recursion = true;

    for (var d = 0, ld = node.needs.length; d < ld; ++d) {
      var dep = node.needs[d];

      if (!dep.node.visited && this.isCyclicNode(dep.node)) {
        return true;
      } else if (dep.node.recursion) {
        return true;
      }
    }
  }

  node.recursion = false;
  return false;
};

DependencyGraph.prototype.clearFlags = function (nodes) {
  for (var n = 0, ln = nodes.length; n < ln; ++n) {
    var node = nodes[n];

    node.visited = false;
    node.recursion = false;
  }
};

function getNode(nodes, id) {
  return nodes[id];
}

function getRefMap(refMap, refId) {
  return refMap[refId];
}

function setRefMap(refMap, refId, actualId) {
  refMap[refId] = actualId;
}

function getRelated(model, relName) {
  return model[relName];
}

function getRelation(relations, relName) {
  return relations[relName];
}

function getTableInsertion(batch, table) {
  return batch[table];
}

function setTableInsertion(batch, table, insertion) {
  batch[table] = insertion;
}

function getUidRef(model) {
  return model[model.constructor.uidRefProp];
}

function getUid(model) {
  return model[model.constructor.uidProp];
}

function setUid(model, id) {
  return model[model.constructor.uidProp] = id;
}

function isInputNode(inputNodesById, node) {
  return !!inputNodesById[node.id];
}

function allMatches(regex, str, cb) {
  var matchResult = regex.exec(str);

  while (matchResult) {
    cb(matchResult);
    matchResult = regex.exec(str);
  }
}