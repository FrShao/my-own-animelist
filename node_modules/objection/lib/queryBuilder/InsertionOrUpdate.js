'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _QueryBuilderBase = require('./QueryBuilderBase');

var _QueryBuilderBase2 = _interopRequireDefault(_QueryBuilderBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Internal representation of insert and update data.
 *
 * Data passed to update or insert queries can be:
 *
 *  1. Javascript primitives
 *  2. knex raw SQL expressions
 *  3. knex queries
 *  4. objection queries
 *
 * This class splits the insert data into two parts:
 *
 *  Part 1:
 *    * Javascript primitives
 *
 *  Part 2:
 *    * everything else
 *
 * The part 1 is converted into `Model` instances and the part 2 is left untouched. As the `InsertionOrUpdate`
 * instance passes through objection during an insert or update operation, the different functions can operate
 * on the models (for example call $beforeInsert etc. methods on them). When the `InsertionOrUpdate` instance
 * finally reaches knex, the two parts are glued back together.
 *
 * @ignore
 */

var InsertionOrUpdate = function () {
  function InsertionOrUpdate(_ref) {
    var ModelClass = _ref.ModelClass;
    var modelsOrObjects = _ref.modelsOrObjects;
    var modelOptions = _ref.modelOptions;
    (0, _classCallCheck3.default)(this, InsertionOrUpdate);

    this.ModelClass = ModelClass;

    this._models = [];
    this._rawOrQuery = [];
    this._arrayInput = false;

    this.setData(modelsOrObjects, modelOptions);
  }

  (0, _createClass3.default)(InsertionOrUpdate, [{
    key: 'model',
    value: function model() {
      return this._models[0];
    }
  }, {
    key: 'models',
    value: function models() {
      return this._models;
    }

    /**
     * Returns true if the input to `setData` method was an array.
     *
     * @ignore
     * @returns {boolean}
     */

  }, {
    key: 'isArray',
    value: function isArray() {
      return this._arrayInput;
    }

    /**
     * Sets the actual insert/update data.
     *
     * @ignore
     * @param {(Object|Array.<Object>)} data
     * @param {ModelOptions} modelOptions
     */

  }, {
    key: 'setData',
    value: function setData(data, modelOptions) {
      var _this = this;

      var knex = this.ModelClass.knex();
      var KnexQueryBuilder = knex.client.QueryBuilder;
      var Raw = knex.client.Raw;

      // knex.QueryBuilder and knex.Raw are not documented properties.
      // We make sure here that things break if knex changes things.
      if (!_lodash2.default.isFunction(KnexQueryBuilder) || !_lodash2.default.isFunction(Raw)) {
        throw new Error('knex API has changed: knex.QueryBuilder or knex.Raw constructor missing.');
      }

      this._models = [];
      this._rawOrQuery = [];
      this._arrayInput = _lodash2.default.isArray(data);

      if (!this._arrayInput) {
        data = _lodash2.default.isObject(data) ? [data] : [];
      }

      // Separate raw queries and query builders from javascript primitives.
      // The javascript primitives are converted into a Model instance and the
      // "query" properties are stored separately.
      _lodash2.default.forEach(data, function (obj) {
        if (obj instanceof _this.ModelClass) {
          _this._models.push(obj);
          _this._rawOrQuery.push({});
        } else {
          (function () {
            var modelJson = {};
            var rawOrSubquery = {};

            _lodash2.default.forEach(obj, function (value, key) {
              if (value instanceof KnexQueryBuilder || value instanceof Raw) {
                rawOrSubquery[key] = value;
              } else if (value instanceof _QueryBuilderBase2.default) {
                rawOrSubquery[key] = value.build();
              } else {
                modelJson[key] = value;
              }
            });

            _this._models.push(_this.ModelClass.fromJson(modelJson, modelOptions));
            _this._rawOrQuery.push(rawOrSubquery);
          })();
        }
      });
    }

    /**
     * Create an object that can be given for the knex update or insert method.
     *
     * @ignore
     * @returns {Object|Array.<Object>}
     */

  }, {
    key: 'toKnexInput',
    value: function toKnexInput() {
      var _this2 = this;

      var knexInput = _lodash2.default.map(this._models, function (model, i) {
        return _lodash2.default.merge(model.$toDatabaseJson(), _lodash2.default.mapKeys(_this2._rawOrQuery[i], function (value, key) {
          return model.constructor.propertyNameToColumnName(key);
        }));
      });

      return knexInput.length === 1 ? knexInput[0] : knexInput;
    }
  }]);
  return InsertionOrUpdate;
}();

exports.default = InsertionOrUpdate;