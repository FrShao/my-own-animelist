import {
  Box_default,
  Error_default,
  createEventForwarder,
  createStyles,
  useActions
} from "./chunk-H3WODAA3.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  assign,
  bind,
  binding_callbacks,
  claim_component,
  claim_space,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  init,
  insert_hydration_dev,
  mount_component,
  safe_not_equal,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BJ76AV5Z.js";

// node_modules/@svelteuidev/core/components/Text/Text.styles.js
function getTextColor(color, variant, gradient, dark = false) {
  if (color === "dimmed")
    return dark ? "$dark200" : "$gray600";
  if (variant === "gradient" || gradient)
    return `$${color}600`;
  if (variant === "link")
    return dark ? `$blue400` : `$blue700`;
  if (variant === "text")
    return dark ? `$${color}500` : `$${color}700`;
}
var Text_styles_default = createStyles((theme, { align, color, inherit, inline, lineClamp, size, tracking, transform, underline, weight, gradient, variant }) => {
  var _a;
  return {
    root: {
      focusRing: "auto",
      [`${theme.dark} &`]: {
        color: color === "dark" ? "$dark50" : getTextColor(color, variant, gradient, true)
      },
      fontFamily: inherit ? "inherit" : "$standard",
      fontSize: inherit ? "inherit" : typeof size === "string" ? `$${size}` : `${size}px`,
      fontWeight: inherit ? "inherit" : `$${weight}`,
      letterSpacing: (_a = theme.letterSpacings[tracking]) == null ? void 0 : _a.value,
      lineHeight: inherit ? "inherit" : inline ? 1 : typeof size === "string" ? `$${size}` : `${size}px`,
      textTransform: transform,
      textDecoration: underline ? "underline" : "none",
      textAlign: align,
      cursor: variant === "link" ? "pointer" : "inherit",
      color: color === "green" ? "Black" : getTextColor(color, variant, gradient),
      backgroundImage: variant === "gradient" ? `linear-gradient(${gradient == null ? void 0 : gradient.deg}deg, $${gradient == null ? void 0 : gradient.from}600 0%, $${gradient == null ? void 0 : gradient.to}600 100%)` : null,
      WebkitBackgroundClip: variant === "gradient" ? "text" : null,
      WebkitTextFillColor: variant === "gradient" ? "transparent" : null,
      ...lineClamp !== void 0 ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitLineClamp: lineClamp,
        WebkitBoxOrient: "vertical"
      } : {},
      "&:hover": variant === "link" && underline === true ? {
        textDecoration: "underline"
      } : void 0
    }
  };
});

// node_modules/@svelteuidev/core/components/Text/Text.errors.js
var TextErrors = Object.freeze([
  {
    error: true,
    message: "If using the 'gradient' prop, set 'variant' prop to 'gradient' to apply the gradient",
    solution: `
                If your component looks like this:

                &lt;Text gradient={{from: 'blue', to: 'red', deg: 45}}&gt;Text string &lt;/Text&gt;
                                                                    ^^^ - Try adding prop variant='gradient'
                `
  },
  {
    error: true,
    message: "If using the 'link' variant, an href needs to be set and the root must be an anchor",
    solution: `
                If your component looks like this:

                &lt;Text variant='link'&gt;Text string &lt;/Text&gt;
                                    ^^^ - Try adding props href && root={'a'}'
                `
  }
]);

// node_modules/@svelteuidev/core/components/Text/Text.svelte
var { Error: Error_1 } = globals;
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[24].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[26], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(default_slot_template, ctx2[26], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(52:0) <Box  {root}  bind:element  use={[forwardEvents, [useActions, use]]}  class={cx(className, getStyles({ css: override }))}  href={href ?? undefined}  {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  var _a;
  let error;
  let t;
  let box;
  let updating_element;
  let current;
  error = new Error_default({
    props: {
      observable: ctx[6],
      component: "Text",
      code: ctx[7]
    },
    $$inline: true
  });
  const box_spread_levels = [
    { root: ctx[4] },
    {
      use: [ctx[10], [useActions, ctx[1]]]
    },
    {
      class: ctx[9](ctx[2], ctx[8]({ css: ctx[3] }))
    },
    { href: (_a = ctx[5]) != null ? _a : void 0 },
    ctx[11]
  ];
  function box_element_binding(value) {
    ctx[25](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < box_spread_levels.length; i += 1) {
    box_props = assign(box_props, box_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    box_props.element = ctx[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      const error_changes = {};
      if (dirty & 64)
        error_changes.observable = ctx2[6];
      if (dirty & 128)
        error_changes.code = ctx2[7];
      error.$set(error_changes);
      const box_changes = dirty & 3902 ? get_spread_update(box_spread_levels, [
        dirty & 16 && { root: ctx2[4] },
        dirty & 1026 && {
          use: [ctx2[10], [useActions, ctx2[1]]]
        },
        dirty & 780 && {
          class: ctx2[9](ctx2[2], ctx2[8]({ css: ctx2[3] }))
        },
        dirty & 32 && { href: (_a2 = ctx2[5]) != null ? _a2 : void 0 },
        dirty & 2048 && get_spread_object(ctx2[11])
      ]) : {};
      if (dirty & 67108864) {
        box_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & 1) {
        updating_element = true;
        box_changes.element = ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(error, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let cx;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "align",
    "color",
    "root",
    "transform",
    "variant",
    "size",
    "weight",
    "gradient",
    "inline",
    "lineClamp",
    "underline",
    "inherit",
    "href",
    "tracking"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { use = [], element = void 0, class: className = "", override = {}, align = "left", color = "dark", root = void 0, transform = "none", variant = "text", size = "md", weight = "normal", gradient = { from: "indigo", to: "cyan", deg: 45 }, inline = true, lineClamp = void 0, underline = false, inherit = false, href = "", tracking = "normal" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  let observable = false;
  let err;
  if (gradient === { from: "indigo", to: "cyan", deg: 45 } && variant !== "gradient") {
    observable = true;
    err = TextErrors[0];
  }
  function box_element_binding(value) {
    element = value;
    $$invalidate(0, element);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("align" in $$new_props)
      $$invalidate(12, align = $$new_props.align);
    if ("color" in $$new_props)
      $$invalidate(13, color = $$new_props.color);
    if ("root" in $$new_props)
      $$invalidate(4, root = $$new_props.root);
    if ("transform" in $$new_props)
      $$invalidate(14, transform = $$new_props.transform);
    if ("variant" in $$new_props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("size" in $$new_props)
      $$invalidate(16, size = $$new_props.size);
    if ("weight" in $$new_props)
      $$invalidate(17, weight = $$new_props.weight);
    if ("gradient" in $$new_props)
      $$invalidate(18, gradient = $$new_props.gradient);
    if ("inline" in $$new_props)
      $$invalidate(19, inline = $$new_props.inline);
    if ("lineClamp" in $$new_props)
      $$invalidate(20, lineClamp = $$new_props.lineClamp);
    if ("underline" in $$new_props)
      $$invalidate(21, underline = $$new_props.underline);
    if ("inherit" in $$new_props)
      $$invalidate(22, inherit = $$new_props.inherit);
    if ("href" in $$new_props)
      $$invalidate(5, href = $$new_props.href);
    if ("tracking" in $$new_props)
      $$invalidate(23, tracking = $$new_props.tracking);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Text_styles_default,
    TextErrors,
    Error: Error_default,
    Box: Box_default,
    createEventForwarder,
    useActions,
    get_current_component,
    use,
    element,
    className,
    override,
    align,
    color,
    root,
    transform,
    variant,
    size,
    weight,
    gradient,
    inline,
    lineClamp,
    underline,
    inherit,
    href,
    tracking,
    forwardEvents,
    observable,
    err,
    getStyles,
    cx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("align" in $$props)
      $$invalidate(12, align = $$new_props.align);
    if ("color" in $$props)
      $$invalidate(13, color = $$new_props.color);
    if ("root" in $$props)
      $$invalidate(4, root = $$new_props.root);
    if ("transform" in $$props)
      $$invalidate(14, transform = $$new_props.transform);
    if ("variant" in $$props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("size" in $$props)
      $$invalidate(16, size = $$new_props.size);
    if ("weight" in $$props)
      $$invalidate(17, weight = $$new_props.weight);
    if ("gradient" in $$props)
      $$invalidate(18, gradient = $$new_props.gradient);
    if ("inline" in $$props)
      $$invalidate(19, inline = $$new_props.inline);
    if ("lineClamp" in $$props)
      $$invalidate(20, lineClamp = $$new_props.lineClamp);
    if ("underline" in $$props)
      $$invalidate(21, underline = $$new_props.underline);
    if ("inherit" in $$props)
      $$invalidate(22, inherit = $$new_props.inherit);
    if ("href" in $$props)
      $$invalidate(5, href = $$new_props.href);
    if ("tracking" in $$props)
      $$invalidate(23, tracking = $$new_props.tracking);
    if ("observable" in $$props)
      $$invalidate(6, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(7, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(8, getStyles = $$new_props.getStyles);
    if ("cx" in $$props)
      $$invalidate(9, cx = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16773120) {
      $:
        $$invalidate(
          9,
          { cx, getStyles } = Text_styles_default({
            lineClamp,
            underline,
            inline,
            inherit,
            gradient,
            variant,
            align,
            color,
            transform,
            size,
            weight,
            tracking
          }),
          cx,
          ($$invalidate(8, getStyles), $$invalidate(20, lineClamp), $$invalidate(21, underline), $$invalidate(19, inline), $$invalidate(22, inherit), $$invalidate(18, gradient), $$invalidate(15, variant), $$invalidate(12, align), $$invalidate(13, color), $$invalidate(14, transform), $$invalidate(16, size), $$invalidate(17, weight), $$invalidate(23, tracking))
        );
    }
  };
  return [
    element,
    use,
    className,
    override,
    root,
    href,
    observable,
    err,
    getStyles,
    cx,
    forwardEvents,
    $$restProps,
    align,
    color,
    transform,
    variant,
    size,
    weight,
    gradient,
    inline,
    lineClamp,
    underline,
    inherit,
    tracking,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      align: 12,
      color: 13,
      root: 4,
      transform: 14,
      variant: 15,
      size: 16,
      weight: 17,
      gradient: 18,
      inline: 19,
      lineClamp: 20,
      underline: 21,
      inherit: 22,
      href: 5,
      tracking: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get weight() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set weight(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineClamp() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineClamp(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get underline() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set underline(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inherit() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inherit(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tracking() {
    throw new Error_1("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tracking(value) {
    throw new Error_1("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

export {
  Text_default
};
//# sourceMappingURL=chunk-Q6S6DGQS.js.map
