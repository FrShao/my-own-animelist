import "./chunk-RNAHHGWI.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  check_outros,
  children,
  claim_element,
  claim_space,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  prevent_default,
  run_all,
  safe_not_equal,
  space,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BJ76AV5Z.js";
import "./chunk-JC4IRQUL.js";

// node_modules/svelma/src/utils/index.js
function isDeleteKey(e) {
  return e.keyCode && e.keyCode === 46;
}

// node_modules/svelma/src/components/Tag/Tag.svelte
var file = "I:/200_2e Annee/202_Informaticien 2e/PR-WEB 21/P_Practice/svelte/app-anime/node_modules/svelma/src/components/Tag/Tag.svelte";
function create_else_block(ctx) {
  let span1;
  let span0;
  let t;
  let span1_class_value;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let if_block = ctx[3] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      if (default_slot)
        default_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t = claim_space(span1_nodes);
      if (if_block)
        if_block.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span0, "has-ellipsis", ctx[5]);
      add_location(span0, file, 77, 8, 2241);
      attr_dev(span1, "class", span1_class_value = "tag " + ctx[0] + " " + ctx[1]);
      toggle_class(span1, "is-rounded", ctx[2]);
      add_location(span1, file, 74, 4, 2157);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      append_hydration_dev(span1, t);
      if (if_block)
        if_block.m(span1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        toggle_class(span0, "has-ellipsis", ctx2[5]);
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 3 && span1_class_value !== (span1_class_value = "tag " + ctx2[0] + " " + ctx2[1])) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (!current || dirty & 7) {
        toggle_class(span1, "is-rounded", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(74:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let span1;
  let span0;
  let span1_class_value;
  let t;
  let a;
  let a_class_value;
  let a_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const block = {
    c: function create() {
      div = element("div");
      span1 = element("span");
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      t = space();
      a = element("a");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      if (default_slot)
        default_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      a = claim_element(div_nodes, "A", {
        role: true,
        class: true,
        disabled: true,
        tabindex: true
      });
      children(a).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span0, "has-ellipsis", ctx[5]);
      add_location(span0, file, 60, 12, 1757);
      attr_dev(span1, "class", span1_class_value = "tag " + ctx[0] + " " + ctx[1]);
      toggle_class(span1, "is-rounded", ctx[2]);
      add_location(span1, file, 57, 8, 1661);
      attr_dev(a, "role", "button");
      attr_dev(a, "class", a_class_value = "tag is-delete " + ctx[1]);
      attr_dev(a, "disabled", ctx[7]);
      attr_dev(a, "tabindex", a_tabindex_value = ctx[6] ? 0 : false);
      toggle_class(a, "is-rounded", ctx[2]);
      add_location(a, file, 64, 8, 1862);
      attr_dev(div, "class", "tags has-addons");
      add_location(div, file, 56, 4, 1623);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span1);
      append_hydration_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      append_hydration_dev(div, t);
      append_hydration_dev(div, a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[8], false, false, false),
          listen_dev(a, "keyup", prevent_default(ctx[11]), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        toggle_class(span0, "has-ellipsis", ctx2[5]);
      }
      if (!current || dirty & 3 && span1_class_value !== (span1_class_value = "tag " + ctx2[0] + " " + ctx2[1])) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (!current || dirty & 7) {
        toggle_class(span1, "is-rounded", ctx2[2]);
      }
      if (!current || dirty & 2 && a_class_value !== (a_class_value = "tag is-delete " + ctx2[1])) {
        attr_dev(a, "class", a_class_value);
      }
      if (!current || dirty & 128) {
        attr_dev(a, "disabled", ctx2[7]);
      }
      if (!current || dirty & 64 && a_tabindex_value !== (a_tabindex_value = ctx2[6] ? 0 : false)) {
        attr_dev(a, "tabindex", a_tabindex_value);
      }
      if (!current || dirty & 6) {
        toggle_class(a, "is-rounded", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(56:0) {#if attached && closable}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let a;
  let a_tabindex_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        role: true,
        class: true,
        disabled: true,
        tabindex: true
      });
      children(a).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "role", "button");
      attr_dev(a, "class", "delete is-small");
      attr_dev(a, "disabled", ctx[7]);
      attr_dev(a, "tabindex", a_tabindex_value = ctx[6] ? 0 : false);
      add_location(a, file, 81, 12, 2349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[8], false, false, false),
          listen_dev(a, "keyup", prevent_default(ctx[12]), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 128) {
        attr_dev(a, "disabled", ctx2[7]);
      }
      if (dirty & 64 && a_tabindex_value !== (a_tabindex_value = ctx2[6] ? 0 : false)) {
        attr_dev(a, "tabindex", a_tabindex_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(81:8) {#if closable}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4] && ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tag", slots, ["default"]);
  let { type = "" } = $$props;
  let { size = "" } = $$props;
  let { rounded = false } = $$props;
  let { closable = false } = $$props;
  let { attached = false } = $$props;
  let { ellipsis = false } = $$props;
  let { tabstop = true } = $$props;
  let { disabled = false } = $$props;
  const dispatch = createEventDispatcher();
  function close() {
    if (this.disabled)
      return;
    dispatch("close");
  }
  const writable_props = [
    "type",
    "size",
    "rounded",
    "closable",
    "attached",
    "ellipsis",
    "tabstop",
    "disabled"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tag> was created with unknown prop '${key}'`);
  });
  const keyup_handler = (e) => isDeleteKey() && close();
  const keyup_handler_1 = (e) => isDeleteKey() && close();
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("rounded" in $$props2)
      $$invalidate(2, rounded = $$props2.rounded);
    if ("closable" in $$props2)
      $$invalidate(3, closable = $$props2.closable);
    if ("attached" in $$props2)
      $$invalidate(4, attached = $$props2.attached);
    if ("ellipsis" in $$props2)
      $$invalidate(5, ellipsis = $$props2.ellipsis);
    if ("tabstop" in $$props2)
      $$invalidate(6, tabstop = $$props2.tabstop);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    isDeleteKey,
    createEventDispatcher,
    type,
    size,
    rounded,
    closable,
    attached,
    ellipsis,
    tabstop,
    disabled,
    dispatch,
    close
  });
  $$self.$inject_state = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("rounded" in $$props2)
      $$invalidate(2, rounded = $$props2.rounded);
    if ("closable" in $$props2)
      $$invalidate(3, closable = $$props2.closable);
    if ("attached" in $$props2)
      $$invalidate(4, attached = $$props2.attached);
    if ("ellipsis" in $$props2)
      $$invalidate(5, ellipsis = $$props2.ellipsis);
    if ("tabstop" in $$props2)
      $$invalidate(6, tabstop = $$props2.tabstop);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    size,
    rounded,
    closable,
    attached,
    ellipsis,
    tabstop,
    disabled,
    close,
    $$scope,
    slots,
    keyup_handler,
    keyup_handler_1
  ];
}
var Tag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      type: 0,
      size: 1,
      rounded: 2,
      closable: 3,
      attached: 4,
      ellipsis: 5,
      tabstop: 6,
      disabled: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment.name
    });
  }
  get type() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closable() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closable(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attached() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attached(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ellipsis() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ellipsis(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabstop() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabstop(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tag_default = Tag;
export {
  Tag_default as default
};
//# sourceMappingURL=svelma_src_components_Tag_Tag__svelte.js.map
