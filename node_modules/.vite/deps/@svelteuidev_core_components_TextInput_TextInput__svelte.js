import {
  InputWrapper_default,
  Input_default
} from "./chunk-6GVRAIBD.js";
import "./chunk-Q6S6DGQS.js";
import {
  createEventForwarder,
  useActions
} from "./chunk-H3WODAA3.js";
import "./chunk-QKQJIKFJ.js";
import "./chunk-RNAHHGWI.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  assign,
  bind,
  binding_callbacks,
  claim_component,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  dispatch_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  init,
  mount_component,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BJ76AV5Z.js";
import "./chunk-22TNCCH5.js";
import {
  __export
} from "./chunk-JC4IRQUL.js";

// node_modules/@svelteuidev/core/components/Input/Input.errors.js
var Input_errors_exports = {};
__export(Input_errors_exports, {
  TextErrors: () => TextErrors
});
var TextErrors = Object.freeze([
  {
    error: true,
    message: "Message",
    solution: `
                If your component looks like this:

                &lt;Input placeholder='placeholder' /&gt;
						  ^^^ - Try adding prop variant='gradient'
                `
  }
]);

// node_modules/@svelteuidev/core/components/TextInput/TextInput.svelte
var get_rightSection_slot_changes = (dirty) => ({});
var get_rightSection_slot_context = (ctx) => ({ slot: "rightSection" });
function create_rightSection_slot(ctx) {
  let current;
  const rightSection_slot_template = ctx[23].rightSection;
  const rightSection_slot = create_slot(rightSection_slot_template, ctx, ctx[26], get_rightSection_slot_context);
  const block = {
    c: function create() {
      if (rightSection_slot)
        rightSection_slot.c();
    },
    l: function claim(nodes) {
      if (rightSection_slot)
        rightSection_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (rightSection_slot) {
        rightSection_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty & 67108864)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(rightSection_slot_template, ctx2[26], dirty, get_rightSection_slot_changes),
            get_rightSection_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot.name,
    type: "slot",
    source: "(65:2) ",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let input;
  let updating_value;
  let current;
  const input_spread_levels = [
    { overrideInput: ctx[5] },
    { required: ctx[9] },
    { size: ctx[15] },
    { id: ctx[13] },
    { placeholder: ctx[16] },
    ctx[20],
    {
      use: [ctx[18], [useActions, ctx[2]]]
    },
    { invalid: ctx[17] },
    {
      showRightSection: ctx[19]
    }
  ];
  function input_value_binding(value) {
    ctx[24](value);
  }
  let input_props = {
    $$slots: { rightSection: [create_rightSection_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < input_spread_levels.length; i += 1) {
    input_props = assign(input_props, input_spread_levels[i]);
  }
  if (ctx[1] !== void 0) {
    input_props.value = ctx[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  const block = {
    c: function create() {
      create_component(input.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(input.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const input_changes = dirty & 2073124 ? get_spread_update(input_spread_levels, [
        dirty & 32 && { overrideInput: ctx2[5] },
        dirty & 512 && { required: ctx2[9] },
        dirty & 32768 && { size: ctx2[15] },
        dirty & 8192 && { id: ctx2[13] },
        dirty & 65536 && { placeholder: ctx2[16] },
        dirty & 1048576 && get_spread_object(ctx2[20]),
        dirty & 262148 && {
          use: [ctx2[18], [useActions, ctx2[2]]]
        },
        dirty & 131072 && { invalid: ctx2[17] },
        dirty & 524288 && {
          showRightSection: ctx2[19]
        }
      ]) : {};
      if (dirty & 67108864) {
        input_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & 2) {
        updating_value = true;
        input_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(input, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(38:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  {id}  {labelElement}  {size} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let inputwrapper;
  let updating_element;
  let current;
  function inputwrapper_element_binding(value) {
    ctx[25](value);
  }
  let inputwrapper_props = {
    class: ctx[3],
    override: ctx[4],
    label: ctx[6],
    description: ctx[7],
    error: ctx[8],
    required: ctx[9],
    labelProps: ctx[10],
    descriptionProps: ctx[11],
    errorProps: ctx[12],
    id: ctx[13],
    labelElement: ctx[14],
    size: ctx[15],
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    inputwrapper_props.element = ctx[0];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const inputwrapper_changes = {};
      if (dirty & 8)
        inputwrapper_changes.class = ctx2[3];
      if (dirty & 16)
        inputwrapper_changes.override = ctx2[4];
      if (dirty & 64)
        inputwrapper_changes.label = ctx2[6];
      if (dirty & 128)
        inputwrapper_changes.description = ctx2[7];
      if (dirty & 256)
        inputwrapper_changes.error = ctx2[8];
      if (dirty & 512)
        inputwrapper_changes.required = ctx2[9];
      if (dirty & 1024)
        inputwrapper_changes.labelProps = ctx2[10];
      if (dirty & 2048)
        inputwrapper_changes.descriptionProps = ctx2[11];
      if (dirty & 4096)
        inputwrapper_changes.errorProps = ctx2[12];
      if (dirty & 8192)
        inputwrapper_changes.id = ctx2[13];
      if (dirty & 16384)
        inputwrapper_changes.labelElement = ctx2[14];
      if (dirty & 32768)
        inputwrapper_changes.size = ctx2[15];
      if (dirty & 68395558) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & 1) {
        updating_element = true;
        inputwrapper_changes.element = ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let _invalid;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "overrideInput",
    "label",
    "description",
    "error",
    "required",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "invalid",
    "id",
    "labelElement",
    "size",
    "showRightSection",
    "value",
    "placeholder"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextInput", slots, ["rightSection"]);
  const $$slots = compute_slots(slots);
  let { use = [], element = void 0, class: className = "", override = {}, overrideInput = {}, label = "", description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, invalid = false, id = "input-id", labelElement = "label", size = "sm", showRightSection = void 0, value = "", placeholder = "" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const _showRightSection = showRightSection === void 0 ? !!$$slots.rightSection : showRightSection;
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function inputwrapper_element_binding(value2) {
    element = value2;
    $$invalidate(0, element);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("overrideInput" in $$new_props)
      $$invalidate(5, overrideInput = $$new_props.overrideInput);
    if ("label" in $$new_props)
      $$invalidate(6, label = $$new_props.label);
    if ("description" in $$new_props)
      $$invalidate(7, description = $$new_props.description);
    if ("error" in $$new_props)
      $$invalidate(8, error = $$new_props.error);
    if ("required" in $$new_props)
      $$invalidate(9, required = $$new_props.required);
    if ("labelProps" in $$new_props)
      $$invalidate(10, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$new_props)
      $$invalidate(11, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$new_props)
      $$invalidate(12, errorProps = $$new_props.errorProps);
    if ("invalid" in $$new_props)
      $$invalidate(21, invalid = $$new_props.invalid);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("labelElement" in $$new_props)
      $$invalidate(14, labelElement = $$new_props.labelElement);
    if ("size" in $$new_props)
      $$invalidate(15, size = $$new_props.size);
    if ("showRightSection" in $$new_props)
      $$invalidate(22, showRightSection = $$new_props.showRightSection);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(16, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    useActions,
    get_current_component,
    InputWrapper: InputWrapper_default,
    Input: Input_default,
    use,
    element,
    className,
    override,
    overrideInput,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    invalid,
    id,
    labelElement,
    size,
    showRightSection,
    value,
    placeholder,
    forwardEvents,
    _showRightSection,
    _invalid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("overrideInput" in $$props)
      $$invalidate(5, overrideInput = $$new_props.overrideInput);
    if ("label" in $$props)
      $$invalidate(6, label = $$new_props.label);
    if ("description" in $$props)
      $$invalidate(7, description = $$new_props.description);
    if ("error" in $$props)
      $$invalidate(8, error = $$new_props.error);
    if ("required" in $$props)
      $$invalidate(9, required = $$new_props.required);
    if ("labelProps" in $$props)
      $$invalidate(10, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$props)
      $$invalidate(11, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$props)
      $$invalidate(12, errorProps = $$new_props.errorProps);
    if ("invalid" in $$props)
      $$invalidate(21, invalid = $$new_props.invalid);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("labelElement" in $$props)
      $$invalidate(14, labelElement = $$new_props.labelElement);
    if ("size" in $$props)
      $$invalidate(15, size = $$new_props.size);
    if ("showRightSection" in $$props)
      $$invalidate(22, showRightSection = $$new_props.showRightSection);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(16, placeholder = $$new_props.placeholder);
    if ("_invalid" in $$props)
      $$invalidate(17, _invalid = $$new_props._invalid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2097408) {
      $:
        $$invalidate(17, _invalid = invalid || !!error);
    }
  };
  return [
    element,
    value,
    use,
    className,
    override,
    overrideInput,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    id,
    labelElement,
    size,
    placeholder,
    _invalid,
    forwardEvents,
    _showRightSection,
    $$restProps,
    invalid,
    showRightSection,
    slots,
    input_value_binding,
    inputwrapper_element_binding,
    $$scope
  ];
}
var TextInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 4,
      overrideInput: 5,
      label: 6,
      description: 7,
      error: 8,
      required: 9,
      labelProps: 10,
      descriptionProps: 11,
      errorProps: 12,
      invalid: 21,
      id: 13,
      labelElement: 14,
      size: 15,
      showRightSection: 22,
      value: 1,
      placeholder: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextInput",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overrideInput() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overrideInput(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionProps() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionProps(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorProps() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorProps(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelElement() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelElement(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showRightSection() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showRightSection(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextInput_default = TextInput;
export {
  TextInput_default as default
};
//# sourceMappingURL=@svelteuidev_core_components_TextInput_TextInput__svelte.js.map
