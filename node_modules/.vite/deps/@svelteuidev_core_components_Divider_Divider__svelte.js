import {
  Text_default
} from "./chunk-Q6S6DGQS.js";
import {
  Box_default,
  Error_default,
  createStyles
} from "./chunk-H3WODAA3.js";
import "./chunk-QKQJIKFJ.js";
import "./chunk-RNAHHGWI.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  assign,
  bind,
  binding_callbacks,
  check_outros,
  claim_component,
  claim_space,
  claim_text,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  safe_not_equal,
  set_data_dev,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BJ76AV5Z.js";
import "./chunk-22TNCCH5.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@svelteuidev/core/components/Divider/Divider.styles.js
var sizes = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};
var Divider_styles_default = createStyles((theme, { color, size, variant }) => {
  const { size: sizeFn, themeColor } = theme.fn;
  return {
    root: {
      "&.svelteui-Divider-horizontal": {
        border: 0,
        borderTopWidth: typeof size === "number" ? `${size}px` : sizeFn({ size, sizes }),
        borderTopColor: themeColor(color, 4),
        borderTopStyle: variant,
        margin: "12px 0px 12px 0px"
      },
      "&.svelteui-Divider-vertical": {
        border: 0,
        alignSelf: "stretch",
        height: "100%",
        borderLeftWidth: typeof size === "number" ? `${size}px` : sizeFn({ size, sizes }),
        borderLeftColor: themeColor(color, 4),
        borderLeftStyle: variant
      },
      "&.shows-label": {
        borderTop: "0 !important"
      }
    },
    label: {
      display: "flex",
      alignItems: "center",
      color: color === "dark" ? themeColor("dark", 1) : themeColor(color, 6),
      [`${theme.dark} &`]: {
        color: color === "dark" ? themeColor("dark", 1) : themeColor(color, 5)
      },
      "&.left": {
        "&::before": {
          display: "none"
        }
      },
      "&.right": {
        "&::after": {
          display: "none"
        }
      },
      "&::before": {
        content: '""',
        flex: 1,
        height: 1,
        borderTopWidth: typeof size === "number" ? `${size}px` : sizeFn({ size, sizes }),
        borderTopStyle: `${variant}`,
        borderTopColor: themeColor(color, 4),
        marginRight: "10px",
        [`${theme.dark} &`]: {
          borderTopColor: themeColor(color, 3)
        }
      },
      "&::after": {
        content: '""',
        flex: 1,
        borderTopWidth: typeof size === "number" ? `${size}px` : sizeFn({ size, sizes }),
        borderTopStyle: `${variant}`,
        borderTopColor: themeColor(color, 3),
        marginLeft: "10px"
      }
    }
  };
});

// node_modules/@svelteuidev/core/components/Divider/Divider.errors.js
var DividerErrors = Object.freeze([
  {
    error: true,
    message: "If using label or label slot, it cannot use orientation 'vertical'",
    solution: `
                If your component looks like this:
                
                &lt;Divider orientation='vertical' label='text...'&lt;/Divider&gt;
                                        ^^^^^^^^^ - Try changing orientation to 'horizontal'
                `
  }
]);

// node_modules/@svelteuidev/core/components/Divider/Divider.svelte
var { Error: Error_1 } = globals;
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  var _a;
  let text_1;
  let current;
  const text_1_spread_levels = [
    {
      class: ctx[12](ctx[11].label, ctx[6])
    },
    ctx[7],
    {
      size: ((_a = ctx[7]) == null ? void 0 : _a.size) || ctx[4]
    }
  ];
  let text_1_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < text_1_spread_levels.length; i += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i]);
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      const text_1_changes = dirty & 6352 ? get_spread_update(text_1_spread_levels, [
        dirty & 6208 && {
          class: ctx2[12](ctx2[11].label, ctx2[6])
        },
        dirty & 128 && get_spread_object(ctx2[7]),
        dirty & 144 && {
          size: ((_a2 = ctx2[7]) == null ? void 0 : _a2.size) || ctx2[4]
        }
      ]) : {};
      if (dirty & 4194336) {
        text_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(58:1) {#if showsLabel}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(60:22)      ",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const label_slot_template = ctx[20].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[22], get_label_slot_context);
  const label_slot_or_fallback = label_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (label_slot_or_fallback)
        label_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(label_slot_template, ctx2[22], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 32)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(59:2) <Text class={cx(classes.label, labelPosition)} {...labelProps} size={labelProps?.size || size}>",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[15] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[15]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32768) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(44:0) <Box  bind:element  {use}  class={cx(   className,   {    'svelteui-Divider-horizontal': isHorizontal,    'svelteui-Divider-vertical': isVertical,    'shows-label': showsLabel   },   getStyles({ css: override })  )}  {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let error;
  let t;
  let box;
  let updating_element;
  let current;
  error = new Error_default({
    props: {
      observable: ctx[8],
      component: "Divider",
      code: ctx[9]
    },
    $$inline: true
  });
  const box_spread_levels = [
    { use: ctx[2] },
    {
      class: ctx[12](
        ctx[3],
        {
          "svelteui-Divider-horizontal": ctx[14],
          "svelteui-Divider-vertical": ctx[13],
          "shows-label": ctx[15]
        },
        ctx[10]({ css: ctx[1] })
      )
    },
    ctx[16]
  ];
  function box_element_binding(value) {
    ctx[21](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < box_spread_levels.length; i += 1) {
    box_props = assign(box_props, box_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    box_props.element = ctx[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const error_changes = {};
      if (dirty & 256)
        error_changes.observable = ctx2[8];
      if (dirty & 512)
        error_changes.code = ctx2[9];
      error.$set(error_changes);
      const box_changes = dirty & 128014 ? get_spread_update(box_spread_levels, [
        dirty & 4 && { use: ctx2[2] },
        dirty & 62474 && {
          class: ctx2[12](
            ctx2[3],
            {
              "svelteui-Divider-horizontal": ctx2[14],
              "svelteui-Divider-vertical": ctx2[13],
              "shows-label": ctx2[15]
            },
            ctx2[10]({ css: ctx2[1] })
          )
        },
        dirty & 65536 && get_spread_object(ctx2[16])
      ]) : {};
      if (dirty & 4233456) {
        box_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & 1) {
        updating_element = true;
        box_changes.element = ctx2[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(error, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let showsLabel;
  let isVertical;
  let isHorizontal;
  let cx;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "orientation",
    "size",
    "label",
    "labelPosition",
    "labelProps",
    "variant"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Divider", slots, ["label"]);
  const $$slots = compute_slots(slots);
  let { use = [], element = void 0, class: className = "", override = {}, color = "gray", orientation = "horizontal", size = "xs", label = null, labelPosition = "left", labelProps = null, variant = "solid" } = $$props;
  let observable = false;
  let err;
  if (isVertical && (label || $$slots.label)) {
    observable = true;
    err = DividerErrors[0];
  }
  function box_element_binding(value) {
    element = value;
    $$invalidate(0, element);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(1, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(17, color = $$new_props.color);
    if ("orientation" in $$new_props)
      $$invalidate(18, orientation = $$new_props.orientation);
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("labelPosition" in $$new_props)
      $$invalidate(6, labelPosition = $$new_props.labelPosition);
    if ("labelProps" in $$new_props)
      $$invalidate(7, labelProps = $$new_props.labelProps);
    if ("variant" in $$new_props)
      $$invalidate(19, variant = $$new_props.variant);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Divider_styles_default,
    Box: Box_default,
    Text: Text_default,
    Error: Error_default,
    DividerErrors,
    use,
    element,
    className,
    override,
    color,
    orientation,
    size,
    label,
    labelPosition,
    labelProps,
    variant,
    observable,
    err,
    getStyles,
    classes,
    cx,
    isVertical,
    isHorizontal,
    showsLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(1, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(17, color = $$new_props.color);
    if ("orientation" in $$props)
      $$invalidate(18, orientation = $$new_props.orientation);
    if ("size" in $$props)
      $$invalidate(4, size = $$new_props.size);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("labelPosition" in $$props)
      $$invalidate(6, labelPosition = $$new_props.labelPosition);
    if ("labelProps" in $$props)
      $$invalidate(7, labelProps = $$new_props.labelProps);
    if ("variant" in $$props)
      $$invalidate(19, variant = $$new_props.variant);
    if ("observable" in $$props)
      $$invalidate(8, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(9, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(10, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(12, cx = $$new_props.cx);
    if ("isVertical" in $$props)
      $$invalidate(13, isVertical = $$new_props.isVertical);
    if ("isHorizontal" in $$props)
      $$invalidate(14, isHorizontal = $$new_props.isHorizontal);
    if ("showsLabel" in $$props)
      $$invalidate(15, showsLabel = $$new_props.showsLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 262176) {
      $:
        $$invalidate(15, showsLabel = (label || $$slots.label) && orientation === "horizontal");
    }
    if ($$self.$$.dirty & 262144) {
      $:
        $$invalidate(13, isVertical = orientation === "vertical");
    }
    if ($$self.$$.dirty & 262144) {
      $:
        $$invalidate(14, isHorizontal = orientation === "horizontal");
    }
    if ($$self.$$.dirty & 256) {
      $:
        if (observable)
          $$invalidate(1, override = { display: "none" });
    }
    if ($$self.$$.dirty & 655376) {
      $:
        $$invalidate(12, { cx, classes, getStyles } = Divider_styles_default({ color, size, variant }), cx, ($$invalidate(11, classes), $$invalidate(17, color), $$invalidate(4, size), $$invalidate(19, variant)), ($$invalidate(10, getStyles), $$invalidate(17, color), $$invalidate(4, size), $$invalidate(19, variant)));
    }
  };
  return [
    element,
    override,
    use,
    className,
    size,
    label,
    labelPosition,
    labelProps,
    observable,
    err,
    getStyles,
    classes,
    cx,
    isVertical,
    isHorizontal,
    showsLabel,
    $$restProps,
    color,
    orientation,
    variant,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Divider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 1,
      color: 17,
      orientation: 18,
      size: 4,
      label: 5,
      labelPosition: 6,
      labelProps: 7,
      variant: 19
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Divider",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_1("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_1("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Divider_default = Divider;
export {
  Divider_default as default
};
//# sourceMappingURL=@svelteuidev_core_components_Divider_Divider__svelte.js.map
